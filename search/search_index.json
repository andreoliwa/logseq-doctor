{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#logseq-doctor","title":"Logseq Doctor","text":"<p>Logseq Doctor: heal your flat old Markdown files before importing them to Logseq.</p> <p>Project Status</p> <p>This project is still in alpha, so it's very rough on the edges (documentation and feature-wise).</p> Text Only<pre><code>At the moment, it has both a Python and Go CLI.\n\nThe long-term plan is to convert it to Go and slowly remove Python.\nNew features will be added to the Go CLI only.\n</code></pre>"},{"location":"#what-is-logseq-doctor","title":"What is Logseq Doctor?","text":"<p>Logseq Doctor is a command-line tool with commands to manipulate your Logseq Markdown files. It provides utilities to:</p> <ul> <li>Convert flat Markdown to Logseq's outline format</li> <li>Append content to pages and journals</li> <li>Create task backlogs that are easily viewed and prioritized in the mobile app</li> <li>Manage tasks in Logseq</li> <li>Clean up and tidy Markdown files</li> <li>Prevent invalid content to be committed</li> <li>And more stuff to come...</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Backlog Management (<code>backlog</code>): Aggregate tasks from multiple pages into unified backlogs with smart categorization, overdue detection, and focus page generation</li> <li>Content Management (<code>content</code>): Append raw Markdown content to Logseq pages or journals</li> <li>Markdown Integration (<code>md</code>): Parse and add Markdown content using DOM manipulation with support for parent blocks and journal targeting</li> <li>Task Management (<code>task add</code>): Add new tasks or update existing ones with key-based search, preserving children and properties</li> <li>Tidy Up (<code>tidy-up</code>): Clean up and standardize your Markdown files</li> <li>Fast Performance: Written in Go for speed and efficiency</li> <li>Outline Conversion (<code>outline</code>): Convert flat Markdown files to Logseq's outline format</li> <li>Task Listing (<code>tasks</code>): List and manage tasks in your Logseq graph</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide - Get started with Logseq Doctor</li> <li>Usage Guide - Learn how to use the CLI tools</li> <li>Contributing - Help improve Logseq Doctor</li> <li>GitHub Repository</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#installation_1","title":"Installation","text":""},{"location":"#go-binary-executable","title":"Go binary executable","text":"<p>The recommended way for macOS and Linux is to install with Homebrew:</p> Text Only<pre><code>brew install andreoliwa/formulae/logseq-doctor\n</code></pre> <p>Or you can install manually:</p> Text Only<pre><code>go install github.com/andreoliwa/logseq-doctor@latest\n</code></pre> <p>Confirm if it's in your path:</p> Text Only<pre><code>which lqd\n# or\nls -l $(go env GOPATH)/bin/lqd\n</code></pre>"},{"location":"#python-executable","title":"Python executable","text":"<p>The recommended way is to install <code>logseq-doctor</code> globally with pipx:</p> Text Only<pre><code>pipx install logseq-doctor\n</code></pre> <p>You can also install the development version with:</p> Text Only<pre><code>pipx install git+https://github.com/andreoliwa/logseq-doctor\n</code></pre> <p>You will then have the <code>lqdpy</code> command available globally in your system.</p>"},{"location":"#build-from-source","title":"Build from source","text":"<p>To build and install from the source (both Python and Go executables), clone the repository and run:</p> Text Only<pre><code>make install\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#quick-start_1","title":"Quick start","text":"<p>Type <code>lqd</code> (the Go executable) without arguments to check the current commands and options:</p> Text Only<pre><code>Logseq Doctor heals your Markdown files for Logseq.\n\nConvert flat Markdown to Logseq outline, clean up Markdown,\nprevent invalid content, and more stuff to come.\n\n\"lqdpy\" is the CLI tool originally written in Python; \"lqd\" is the Go version.\nThe intention is to slowly convert everything to Go.\n\nUsage:\nlqd [command]\n\nAvailable Commands:\nbacklog     Aggregate tasks from multiple pages into a unified backlog\ncompletion  Generate the autocompletion script for the specified shell\ncontent     Append raw Markdown content to Logseq\nhelp        Help about any command\nmd          Add Markdown content to Logseq using the DOM\ntask        Manage tasks in Logseq (subcommands: add)\ntidy-up     Tidy up your Markdown files\n\nFlags:\n-h, --help   help for lqd\n\nUse \"lqd [command] --help\" for more information about a command.\n</code></pre> <p>Type <code>lqdpy</code> without arguments to check the current commands and options:</p> Text Only<pre><code>Usage: lqdpy [OPTIONS] COMMAND [ARGS]...\n\nLogseq Doctor: heal your flat old Markdown files before importing them.\n\nOptions:\n-g, --graph DIRECTORY           Logseq graph  [env var: LOGSEQ_GRAPH_PATH;\nrequired]\n--install-completion [bash|zsh|fish|powershell|pwsh]\nInstall completion for the specified shell.\n--show-completion [bash|zsh|fish|powershell|pwsh]\nShow completion for the specified shell, to\ncopy it or customize the installation.\n--help                          Show this message and exit.\n\nCommands:\noutline  Convert flat Markdown to outline.\ntasks    List tasks in Logseq.\n</code></pre>"},{"location":"#project-goals","title":"Project Goals","text":"<p>The primary goal of Logseq Doctor is to make it easier to migrate existing Markdown content into Logseq. Whether you're coming from another note-taking system or have a collection of flat Markdown files, Logseq Doctor helps ensure your content is properly formatted for Logseq's outliner-based structure.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#050-2025-02-13","title":"0.5.0 (2025-02-13)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>tasks: JSON format (#121) (07da841)</li> </ul>"},{"location":"changelog/#040-2025-02-11","title":"0.4.0 (2025-02-11)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>deps: update github.com/andreoliwa/logseq-go digest to 276dc3d (62aa9ec)</li> <li>deps: update github.com/andreoliwa/logseq-go digest to 3b9f58b (13e6274)</li> <li>deps: update module github.com/stretchr/testify to v1.10.0 (f737ea4)</li> <li>deps: update module gotest.tools/v3 to v3.5.2 (7ee8efc)</li> <li>deps: update rust crate anyhow to 1.0.80 (3938baa)</li> <li>deps: update rust crate anyhow to 1.0.81 (d5e9425)</li> <li>deps: update rust crate anyhow to v1.0.95 (a0bdcf7)</li> <li>deps: update rust crate assert_fs to v1.1.2 (b55d654)</li> <li>deps: update rust crate chrono to 0.4.34 (8903b29)</li> <li>deps: update rust crate chrono to 0.4.35 (4001ea5)</li> <li>deps: update rust crate chrono to 0.4.37 (8ff6a0b)</li> <li>deps: update rust crate pyo3 to 0.20.3 (c0a566a)</li> <li>deps: update rust crate pyo3 to 0.21.0 (5a75518)</li> <li>deps: update rust crate pyo3 to 0.21.1 (4f9b6b5)</li> <li>deps: update rust crate regex to 1.10.4 (fc033da)</li> <li>deps: update rust crate regex to v1.11.1 (61ed776)</li> <li>don't remove double spaces in tables (253a1d0)</li> <li>make Journal properties public (78b18a2)</li> <li>one transaction per file, to avoid touching unmodified files (b66410b)</li> <li>tasks: use \u00a7 as column separator, to parse with fzf (ccd12e7)</li> </ul>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>append raw Markdown from sdtin to a journal (545b17b)</li> <li>check for running tasks (0bfef8f)</li> <li>check references to forbidden pages (58f9f26)</li> <li>Python calling a Go executable with a simple function (902e54d)</li> <li>tidy-up command accepting Markdown files (0f2e549)</li> <li>tidy-up: check consecutive spaces in Go (#115) (32a02d8)</li> <li>tidy-up: remove double spaces and save Markdown file (212014a)</li> <li>tidy-up: remove empty bullets in Go, remove Python command (a472b30)</li> <li>tidy-up: remove unnecessary brackets from tags (d887e58)</li> <li>tidy-up: remove unnecessary brackets from tags in Go (f01fffd)</li> </ul>"},{"location":"changelog/#v030-2024-02-07","title":"v0.3.0 (2024-02-07)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>journal: option to prepend content</li> <li>journal: choose the date (with natural language)</li> <li>journal: output content to stdout</li> <li>journal: option to convert to outline (#17)</li> <li>journal: pipe content from stdin (#17)</li> <li>journal: append content to the current journal page (#17)</li> </ul>"},{"location":"changelog/#v021-2024-02-04","title":"v0.2.1 (2024-02-04)","text":""},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>automated release with \"make release\" from local computer</li> </ul>"},{"location":"changelog/#v020-2024-02-04","title":"v0.2.0 (2024-02-04)","text":""},{"location":"changelog/#feat_1","title":"Feat","text":"<ul> <li>\"logseq\" crate for reusable functions</li> <li>remove double spaces</li> <li>remove Python 3.7</li> <li>list tasks, add Kanban board (#78)</li> <li>tidy up files by removing empty bullets (#63)</li> <li>rich CLI with Typer</li> </ul>"},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>remove Python 3.8 support</li> <li>preserve line break at the end</li> <li>deps: update dependency mistletoe to v1.3.0</li> <li>remove --format kanban</li> <li>deps: update dependency mistletoe to v1.2.1</li> <li>deps: update dependency mistletoe to v1.2.0</li> <li>deps: update dependency click to v8.1.7</li> <li>Typer needs some imports, UP006 ignores target-version=py38</li> <li>don't print \"Done\" on success</li> <li>deps: update dependency click to v8.1.6</li> <li>deps: update dependency click to v8.1.5</li> <li>deps: update dependency click to v8.1.4</li> <li>deps: update dependency mistletoe to v1.1.0</li> <li>deps: update dependency requests to v2.31.0</li> <li>deps: update dependency requests to v2.30.0</li> <li>deps: update dependency typer to v0.9.0</li> <li>deps: update dependency typer to v0.8.0</li> <li>add Ruff and adjust code</li> <li>deps: update dependency mistletoe to v1</li> <li>deps: upgrade shelligham and pre-commit hooks, fix tox</li> <li>tidy-up: display file name that was fixed</li> <li>handle thematic breaks and setext headers</li> <li>handle nested lists with single or multiple levels (#47)</li> </ul>"},{"location":"changelog/#refactor","title":"Refactor","text":"<ul> <li>rename Python module</li> </ul>"},{"location":"changelog/#v011-2022-08-21","title":"v0.1.1 (2022-08-21)","text":""},{"location":"changelog/#fix_2","title":"Fix","text":"<ul> <li>ImportError on lsd --help</li> </ul>"},{"location":"changelog/#v010-2022-03-26","title":"v0.1.0 (2022-03-26)","text":""},{"location":"changelog/#feat_2","title":"Feat","text":"<ul> <li>convert headers and flat paragraphs to an outline</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#bug-reports","title":"Bug Reports","text":"<p>When reporting a bug, please include:</p> <ul> <li>Your operating system name and version</li> <li>Any details about your local setup that might be helpful in troubleshooting</li> <li>Detailed steps to reproduce the bug</li> </ul>"},{"location":"contributing/#documentation-improvements","title":"Documentation Improvements","text":"<p>Logseq Doctor could always use more documentation, whether as part of the official docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#feature-requests-and-feedback","title":"Feature Requests and Feedback","text":"<p>The best way to send feedback is to file an issue.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work</li> <li>Keep the scope as narrow as possible, to make it easier to implement</li> <li>Remember that this is a volunteer-driven project, and that code contributions are welcome :)</li> </ul>"},{"location":"contributing/#development","title":"Development","text":"<p>To set up <code>logseq-doctor</code> for local development:</p> <ol> <li> <p>Fork logseq-doctor (look for the \"Fork\" button)</p> </li> <li> <p>Clone your fork locally:</p> </li> </ol> Bash<pre><code>git clone git@github.com:YOURGITHUBNAME/logseq-doctor.git\ncd logseq-doctor\n</code></pre> <ol> <li>Set up your local development environment:</li> </ol> Bash<pre><code>make setup\n</code></pre> <p>This will:    - Create a Python virtual environment    - Install Python dependencies    - Set up Go dependencies    - Install development tools</p> <ol> <li>Create a branch for local development:</li> </ol> Bash<pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, run all the checks:</li> </ol> <p>For Python changes:</p> Bash<pre><code>tox\n</code></pre> <p>For Go changes:</p> Bash<pre><code>make test-go\nmake lint-go\n</code></pre> <p>Run all tests:</p> Bash<pre><code>make test\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> Bash<pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>If you need some code review or feedback while you're developing the code, just make the pull request.</p> <p>For merging, you should:</p> <ol> <li>Include passing tests (run <code>tox</code> for Python, <code>make test-go</code> for Go)</li> <li>Update documentation when there's new API, functionality, etc.</li> <li>Add a note to the changelog about the changes</li> </ol>"},{"location":"contributing/#development-tips","title":"Development Tips","text":""},{"location":"contributing/#running-a-subset-of-tests","title":"Running a Subset of Tests","text":"<p>Python:</p> Bash<pre><code>tox -e envname -- pytest -k test_myfeature\n</code></pre> <p>Go:</p> Bash<pre><code>go test -v -run TestMyFeature ./...\n</code></pre>"},{"location":"contributing/#running-tests-in-parallel","title":"Running Tests in Parallel","text":"<p>Python:</p> Bash<pre><code>tox -p auto\n</code></pre> <p>Go:</p> Bash<pre><code>go test -v -parallel 4 ./...\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>Python:</p> <ul> <li>We use <code>black</code> for code formatting</li> <li>We use <code>ruff</code> for linting</li> <li>Run <code>tox -e check</code> to check code style</li> </ul> <p>Go:</p> <ul> <li>We use <code>gofmt</code> for code formatting</li> <li>We use <code>golangci-lint</code> for linting</li> <li>Run <code>make lint-go</code> to check code style</li> </ul>"},{"location":"contributing/#building-documentation-locally","title":"Building Documentation Locally","text":"<p>To build and preview the documentation locally:</p> Bash<pre><code># Install MkDocs and dependencies\npip install -r docs/requirements.txt\n\n# Serve the documentation locally\nmkdocs serve\n</code></pre> <p>Then open http://127.0.0.1:8000 in your browser.</p>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"Text Only<pre><code>logseq-doctor/\n\u251c\u2500\u2500 cmd/              # Go CLI commands\n\u251c\u2500\u2500 internal/         # Go internal packages\n\u251c\u2500\u2500 pkg/              # Go public packages\n\u251c\u2500\u2500 src/              # Python source code\n\u251c\u2500\u2500 tests/            # Python tests\n\u251c\u2500\u2500 docs/             # Documentation (MkDocs)\n\u251c\u2500\u2500 main.go           # Go main entry point\n\u2514\u2500\u2500 pyproject.toml    # Python project configuration\n</code></pre>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please note that this project is released with a Contributor Code of Conduct. By participating in this project you agree to abide by its terms.</p>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>Feel free to open an issue if you have any questions about contributing!</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>Logseq Doctor provides both Go and Python implementations. You can install either or both depending on your needs.</p>"},{"location":"installation/#go-binary-executable","title":"Go Binary Executable","text":""},{"location":"installation/#macos-and-linux-homebrew","title":"macOS and Linux (Homebrew)","text":"<p>The recommended way for macOS and Linux is to install with Homebrew:</p> Bash<pre><code>brew install andreoliwa/formulae/logseq-doctor\n</code></pre>"},{"location":"installation/#manual-installation","title":"Manual Installation","text":"<p>You can install manually using Go:</p> Bash<pre><code>go install github.com/andreoliwa/logseq-doctor@latest\n</code></pre> <p>Confirm if it's in your path:</p> Bash<pre><code>which lqd\n# or\nls -l $(go env GOPATH)/bin/lqd\n</code></pre> <p>Tip</p> <p>Make sure your <code>GOPATH/bin</code> directory is in your system's PATH. You can add it to your shell profile:</p> Text Only<pre><code>```bash\nexport PATH=\"$PATH:$(go env GOPATH)/bin\"\n```\n</code></pre>"},{"location":"installation/#python-executable","title":"Python Executable","text":"<p>The recommended way is to install <code>logseq-doctor</code> globally with pipx:</p> Bash<pre><code>pipx install logseq-doctor\n</code></pre> <p>You can also install the development version with:</p> Bash<pre><code>pipx install git+https://github.com/andreoliwa/logseq-doctor\n</code></pre> <p>You will then have the <code>lqdpy</code> command available globally in your system.</p>"},{"location":"installation/#alternative-pip","title":"Alternative: pip","text":"<p>If you prefer to use pip:</p> Bash<pre><code>pip install logseq-doctor\n</code></pre> <p>Warning</p> <p>Installing with pip may conflict with other Python packages in your system. We recommend using pipx instead.</p>"},{"location":"installation/#build-from-source","title":"Build from Source","text":"<p>To build and install from the source (both Python and Go executables), clone the repository and run:</p> Bash<pre><code>git clone https://github.com/andreoliwa/logseq-doctor.git\ncd logseq-doctor\nmake install\n</code></pre> <p>This will:</p> <ol> <li>Set up a Python virtual environment</li> <li>Install Python dependencies</li> <li>Build the Go binary</li> <li>Install both executables</li> </ol>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":""},{"location":"installation/#python-cli","title":"Python CLI","text":""},{"location":"installation/#go-cli","title":"Go CLI","text":"Bash<pre><code>lqd --help\n</code></pre> <p>You should see the help message with available commands.</p> Bash<pre><code>lqdpy --help\n</code></pre> <p>You should see the help message with available commands.</p>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>Once installed, check out the Usage Guide to learn how to use Logseq Doctor.</p>"},{"location":"readme/","title":"Logseq Doctor","text":""},{"location":"readme/#logseq-doctor","title":"Logseq Doctor","text":"<p>Logseq Doctor: heal your flat old Markdown files before importing them to Logseq.</p> <p>\ud83d\udcda Read the full documentation</p> <p>[!NOTE] This project is still alpha, so it's very rough on the edges (documentation and feature-wise).</p> <p>At the moment, it has both a Python and Go CLI.</p> <p>The long-term plan is to convert it to Go and slowly remove Python. New features will be added to the Go CLI only.</p>"},{"location":"readme/#what-is-logseq-doctor","title":"What is Logseq Doctor?","text":"<p>Logseq Doctor is a command-line tool with commands to manipulate your Logseq Markdown files. It provides utilities to:</p> <ul> <li>Convert flat Markdown to Logseq's outline format</li> <li>Append content to pages and journals</li> <li>Create task backlogs that are easily viewed and prioritized in the mobile app</li> <li>Manage tasks in Logseq</li> <li>Clean up and tidy Markdown files</li> <li>Prevent invalid content to be committed</li> <li>And more stuff to come...</li> </ul>"},{"location":"readme/#features","title":"Features","text":"<ul> <li>Backlog Management (<code>backlog</code>): Aggregate tasks from multiple pages into unified backlogs with smart categorization, overdue detection, and focus page generation</li> <li>Content Management (<code>content</code>): Append raw Markdown content to Logseq pages or journals</li> <li>Markdown Integration (<code>md</code>): Parse and add Markdown content using DOM manipulation with support for parent blocks and journal targeting</li> <li>Task Management (<code>task add</code>): Add new tasks or update existing ones with key-based search, preserving children and properties</li> <li>Tidy Up (<code>tidy-up</code>): Clean up and standardize your Markdown files</li> <li>Fast Performance: Written in Go for speed and efficiency</li> <li>Outline Conversion (<code>outline</code>): Convert flat Markdown files to Logseq's outline format</li> <li>Task Listing (<code>tasks</code>): List and manage tasks in your Logseq graph</li> </ul>"},{"location":"readme/#installation","title":"Installation","text":""},{"location":"readme/#go-binary-executable","title":"Go binary executable","text":"<p>The recommended way for macOS and Linux is to install with Homebrew:</p> Text Only<pre><code>brew install andreoliwa/formulae/logseq-doctor\n</code></pre> <p>Or you can install manually:</p> Text Only<pre><code>go install github.com/andreoliwa/logseq-doctor@latest\n</code></pre> <p>Confirm if it's in your path:</p> Text Only<pre><code>which lqd\n# or\nls -l $(go env GOPATH)/bin/lqd\n</code></pre>"},{"location":"readme/#python-executable","title":"Python executable","text":"<p>The recommended way is to install <code>logseq-doctor</code> globally with pipx:</p> Text Only<pre><code>pipx install logseq-doctor\n</code></pre> <p>You can also install the development version with:</p> Text Only<pre><code>pipx install git+https://github.com/andreoliwa/logseq-doctor\n</code></pre> <p>You will then have the <code>lqdpy</code> command available globally in your system.</p>"},{"location":"readme/#build-from-source","title":"Build from source","text":"<p>To build and install from the source (both Python and Go executables), clone the repository and run:</p> Text Only<pre><code>make install\n</code></pre>"},{"location":"readme/#quick-start","title":"Quick start","text":"<p>Type <code>lqd</code> (the Go executable) without arguments to check the current commands and options:</p> Text Only<pre><code>Logseq Doctor heals your Markdown files for Logseq.\n\nConvert flat Markdown to Logseq outline, clean up Markdown,\nprevent invalid content, and more stuff to come.\n\n\"lqdpy\" is the CLI tool originally written in Python; \"lqd\" is the Go version.\nThe intention is to slowly convert everything to Go.\n\nUsage:\nlqd [command]\n\nAvailable Commands:\nbacklog     Aggregate tasks from multiple pages into a unified backlog\ncompletion  Generate the autocompletion script for the specified shell\ncontent     Append raw Markdown content to Logseq\nhelp        Help about any command\nmd          Add Markdown content to Logseq using the DOM\ntask        Manage tasks in Logseq (subcommands: add)\ntidy-up     Tidy up your Markdown files\n\nFlags:\n-h, --help   help for lqd\n\nUse \"lqd [command] --help\" for more information about a command.\n</code></pre> <p>Type <code>lqdpy</code> without arguments to check the current commands and options:</p> Text Only<pre><code>Usage: lqdpy [OPTIONS] COMMAND [ARGS]...\n\nLogseq Doctor: heal your flat old Markdown files before importing them.\n\nOptions:\n-g, --graph DIRECTORY           Logseq graph  [env var: LOGSEQ_GRAPH_PATH;\nrequired]\n--install-completion [bash|zsh|fish|powershell|pwsh]\nInstall completion for the specified shell.\n--show-completion [bash|zsh|fish|powershell|pwsh]\nShow completion for the specified shell, to\ncopy it or customize the installation.\n--help                          Show this message and exit.\n\nCommands:\noutline  Convert flat Markdown to outline.\ntasks    List tasks in Logseq.\n</code></pre>"},{"location":"readme/#development","title":"Development","text":"<p>To set up local development:</p> Text Only<pre><code>make setup\n</code></pre> <p>Run this to see help on all available targets:</p> Text Only<pre><code>make\n</code></pre> <p>To run all the tests run:</p> Text Only<pre><code>tox\n</code></pre> <p>Note, to combine the coverage data from all the tox environments run:</p> OS Windows set PYTEST_ADDOPTS=--cov-append tox Other PYTEST_ADDOPTS=--cov-append tox"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#usage","title":"Usage","text":"<p>Logseq Doctor provides two CLI tools: <code>lqdpy</code> (Python) and <code>lqd</code> (Go). This guide covers both.</p> <p>Info</p> <p>The Go CLI (<code>lqd</code>) is the recommended version for new features. The Python CLI (<code>lqdpy</code>) is maintained for backward compatibility but new features will only be added to the Go version.</p>"},{"location":"usage/#python-cli-lqdpy","title":"Python CLI (<code>lqdpy</code>)","text":""},{"location":"usage/#overview","title":"Overview","text":"<p>Type <code>lqdpy</code> without arguments to check the current commands and options:</p> Bash<pre><code>lqdpy --help\n</code></pre> <p>Output:</p> Text Only<pre><code>Usage: lqdpy [OPTIONS] COMMAND [ARGS]...\n\nLogseq Doctor: heal your flat old Markdown files before importing them.\n\nOptions:\n  -g, --graph DIRECTORY           Logseq graph  [env var: LOGSEQ_GRAPH_PATH; required]\n  --install-completion [bash|zsh|fish|powershell|pwsh]\n                                  Install completion for the specified shell.\n  --show-completion [bash|zsh|fish|powershell|pwsh]\n                                  Show completion for the specified shell, to\n                                  copy it or customize the installation.\n  --help                          Show this message and exit.\n\nCommands:\n  outline  Convert flat Markdown to outline.\n  tasks    List tasks in Logseq.\n</code></pre>"},{"location":"usage/#setting-the-logseq-graph-path","title":"Setting the Logseq Graph Path","text":"<p>Most commands require you to specify your Logseq graph directory. You can do this in two ways:</p> <ol> <li>Using the <code>-g</code> flag:</li> </ol> Bash<pre><code>lqdpy -g /path/to/your/logseq/graph outline input.md\n</code></pre> <ol> <li>Using the environment variable:</li> </ol> Bash<pre><code>export LOGSEQ_GRAPH_PATH=/path/to/your/logseq/graph\nlqdpy outline input.md\n</code></pre>"},{"location":"usage/#commands","title":"Commands","text":""},{"location":"usage/#outline-convert-flat-markdown-to-outline","title":"<code>outline</code> - Convert Flat Markdown to Outline","text":"<p>Convert flat Markdown files to Logseq's outline format:</p> Bash<pre><code>lqdpy -g /path/to/graph outline input.md\n</code></pre> <p>This command reads a flat Markdown file and converts it to Logseq's indented outline structure.</p>"},{"location":"usage/#tasks-list-tasks-in-logseq","title":"<code>tasks</code> - List Tasks in Logseq","text":"<p>List all tasks in your Logseq graph:</p> Bash<pre><code>lqdpy -g /path/to/graph tasks\n</code></pre> <p>This will display all tasks found in your Logseq pages.</p>"},{"location":"usage/#go-cli-lqd","title":"Go CLI (<code>lqd</code>)","text":""},{"location":"usage/#overview_1","title":"Overview","text":"<p>Type <code>lqd</code> without arguments to check the current commands and options:</p> Bash<pre><code>lqd --help\n</code></pre> <p>Output:</p> Text Only<pre><code>Logseq Doctor heals your Markdown files for Logseq.\n\nConvert flat Markdown to Logseq outline, clean up Markdown,\nprevent invalid content, and more stuff to come.\n\n\"lqdpy\" is the CLI tool originally written in Python; \"lqd\" is the Go version.\nThe intention is to slowly convert everything to Go.\n\nUsage:\n  lqd [command]\n\nAvailable Commands:\n  completion  Generate the autocompletion script for the specified shell\n  content     Append raw Markdown content to Logseq\n  help        Help about any command\n  tidy-up     Tidy up your Markdown files.\n\nFlags:\n  -h, --help   help for lqd\n\nUse \"lqd [command] --help\" for more information about a command.\n</code></pre>"},{"location":"usage/#commands_1","title":"Commands","text":""},{"location":"usage/#content-append-raw-markdown-content","title":"<code>content</code> - Append Raw Markdown Content","text":"<p>Append raw Markdown content to your Logseq graph:</p> Bash<pre><code>lqd content --help\n</code></pre> <p>This command allows you to add content to your Logseq pages programmatically.</p>"},{"location":"usage/#tidy-up-tidy-up-markdown-files","title":"<code>tidy-up</code> - Tidy Up Markdown Files","text":"<p>Clean up and standardize your Markdown files:</p> Bash<pre><code>lqd tidy-up --help\n</code></pre> <p>This command helps ensure your Markdown files follow consistent formatting rules.</p>"},{"location":"usage/#completion-shell-completion","title":"<code>completion</code> - Shell Completion","text":"<p>Generate autocompletion scripts for your shell:</p> Bash<pre><code># For bash\nlqd completion bash &gt; /etc/bash_completion.d/lqd\n\n# For zsh\nlqd completion zsh &gt; \"${fpath[1]}/_lqd\"\n\n# For fish\nlqd completion fish &gt; ~/.config/fish/completions/lqd.fish\n</code></pre>"},{"location":"usage/#examples","title":"Examples","text":""},{"location":"usage/#converting-a-flat-markdown-file","title":"Converting a Flat Markdown File","text":"<p>If you have a flat Markdown file like this:</p> Markdown<pre><code># My Notes\n\nSome content here.\n\n## Section 1\n\nMore content.\n\n### Subsection\n\nDetails.\n</code></pre> <p>You can convert it to Logseq's outline format:</p> Bash<pre><code>lqdpy -g /path/to/graph outline my-notes.md\n</code></pre>"},{"location":"usage/#tidying-up-markdown-files","title":"Tidying Up Markdown Files","text":"<p>To clean up and standardize your Markdown files:</p> Bash<pre><code>lqd tidy-up /path/to/your/markdown/files\n</code></pre>"},{"location":"usage/#tips","title":"Tips","text":"<p>Environment Variables</p> <p>Set <code>LOGSEQ_GRAPH_PATH</code> in your shell profile to avoid typing it every time:</p> Text Only<pre><code>```bash\n# Add to ~/.bashrc, ~/.zshrc, etc.\nexport LOGSEQ_GRAPH_PATH=/path/to/your/logseq/graph\n```\n</code></pre> <p>Shell Completion</p> <p>Enable shell completion for a better CLI experience. See the <code>completion</code> command above.</p>"},{"location":"usage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"usage/#command-not-found","title":"Command Not Found","text":"<p>If you get a \"command not found\" error:</p> <ol> <li>Make sure the tool is installed (see Installation)</li> <li>Check that the installation directory is in your PATH</li> <li>Try running with the full path to the executable</li> </ol>"},{"location":"usage/#permission-denied","title":"Permission Denied","text":"<p>If you get a \"permission denied\" error:</p> <ol> <li>Make sure the executable has execute permissions: <code>chmod +x /path/to/lqd</code></li> <li>Check that you have write permissions to your Logseq graph directory</li> </ol>"},{"location":"usage/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the CLI Reference for detailed command documentation</li> <li>Check out Contributing if you want to help improve Logseq Doctor</li> </ul>"},{"location":"reference/cli/","title":"Overview","text":""},{"location":"reference/cli/#cli-reference","title":"CLI Reference","text":"<p>This page provides detailed reference documentation for all CLI commands in Logseq Doctor.</p>"},{"location":"reference/cli/#commands","title":"Commands","text":""},{"location":"reference/cli/#backlog","title":"<code>backlog</code>","text":"<p>Aggregate tasks from multiple pages into a unified backlog.</p> <p>Usage:</p> Bash<pre><code>lqd backlog [partial page names]\n</code></pre> <p>Description:</p> <p>This command aggregates tasks from one or more pages into a unified backlog page. It reads configuration from a \"backlog\" page in your graph, where each line with page references or tags defines a separate backlog.</p> <p>Features:</p> <ul> <li>Automatic task aggregation: Queries tasks from specified pages using the Logseq API</li> <li>Smart categorization: Organizes tasks into sections (Focus, Overdue, New tasks, Scheduled)</li> <li>Concurrent processing: Processes multiple pages in parallel for better performance</li> <li>Obsolete task removal: Automatically removes tasks that no longer exist in source pages</li> <li>Pin support: Tasks marked with \ud83d\udccc emoji are preserved and not removed</li> <li>Overdue detection: Identifies and highlights tasks past their deadline or scheduled date</li> <li>Focus page: Aggregates focus tasks from all backlogs into a central focus page</li> </ul> <p>Configuration:</p> <p>Create a page named \"backlog\" with lines containing page references or tags. The first page reference determines the backlog page name, and all referenced pages/tags are used as input sources.</p> <p>Example:</p> Bash<pre><code># Process all backlogs\nlqd backlog\n\n# Process only backlogs matching \"work\"\nlqd backlog work\n\n# Process multiple specific backlogs\nlqd backlog computer house\n</code></pre> <p>Environment Variables:</p> <p>This command uses the following environment variables: <code>LOGSEQ_GRAPH_PATH</code>, <code>LOGSEQ_HOST_URL</code>, and <code>LOGSEQ_API_TOKEN</code>.</p>"},{"location":"reference/cli/#completion","title":"<code>completion</code>","text":"<p>Generate shell completion scripts.</p> <p>Usage (Go CLI):</p> Bash<pre><code>lqd completion [bash|zsh|fish|powershell]\n</code></pre> <p>Description:</p> <p>Generate autocompletion scripts for your shell. This enables tab completion for commands and options.</p> <p>Examples:</p> <p>Bash:</p> Bash<pre><code>lqd completion bash &gt; /etc/bash_completion.d/lqd\n</code></pre> <p>Zsh:</p> Bash<pre><code>lqd completion zsh &gt; \"${fpath[1]}/_lqd\"\n</code></pre> <p>Fish:</p> Bash<pre><code>lqd completion fish &gt; ~/.config/fish/completions/lqd.fish\n</code></pre> <p>PowerShell:</p> Bash<pre><code>lqd completion powershell &gt; lqd.ps1\n</code></pre> <p>Usage (Python CLI):</p> <p>Install shell completion for easier command-line usage:</p> <p>Bash:</p> Bash<pre><code>lqdpy --install-completion bash\n</code></pre> <p>Zsh:</p> Bash<pre><code>lqdpy --install-completion zsh\n</code></pre> <p>Fish:</p> Bash<pre><code>lqdpy --install-completion fish\n</code></pre> <p>PowerShell:</p> Bash<pre><code>lqdpy --install-completion powershell\n</code></pre>"},{"location":"reference/cli/#content","title":"<code>content</code>","text":"<p>Append raw Markdown content to your Logseq graph.</p> <p>Usage:</p> Bash<pre><code>lqd content [OPTIONS]\n</code></pre> <p>Description:</p> <p>This command allows you to programmatically add content to your Logseq pages. It's useful for automation and scripting workflows where you want to append content to your knowledge base.</p> <p>Example:</p> Bash<pre><code>echo \"- New note\" | lqd content\n</code></pre>"},{"location":"reference/cli/#md","title":"<code>md</code>","text":"<p>Add Markdown content to Logseq using the DOM.</p> <p>Usage:</p> Bash<pre><code>lqd md [OPTIONS]\n</code></pre> <p>Description:</p> <p>This command reads Markdown content from stdin and adds it to your Logseq graph by parsing and manipulating the document object model (DOM). Unlike the <code>content</code> command which appends raw text, <code>md</code> parses the Markdown structure and properly integrates it into Logseq's outline format.</p> <p>Features:</p> <ul> <li>Markdown parsing: Parses input as Markdown and converts it to Logseq's block structure</li> <li>Parent block support: Can add content as a child of a specific block using <code>--parent</code></li> <li>Journal targeting: Supports adding to specific journal dates with <code>--journal</code></li> <li>Multi-line content: Handles complex Markdown including tasks with properties and logbooks</li> <li>Smart placement: Adds to journal page by default, or under a parent block if specified</li> </ul> <p>Flags:</p> Text Only<pre><code>-j, --journal YYYY-MM-DD    Journal date (default: today)\n-p, --parent TEXT           Partial text of a block to use as parent\n</code></pre> <p>Examples:</p> Bash<pre><code># Add a simple note to today's journal\necho \"New task\" | lqd md\n\n# Add content under a specific parent block\necho \"Child task\" | lqd md --parent \"Project A\"\n\n# Add to a specific journal date\necho \"Meeting notes\" | lqd md --journal 2024-12-25\n\n# Add a task with properties and logbook\necho \"DOING Some task\ncollapsed:: true\n:LOGBOOK:\nCLOCK: [2025-08-27 Wed 21:12:50]\n:END:\" | lqd md --parent \"work\"\n</code></pre>"},{"location":"reference/cli/#outline","title":"<code>outline</code>","text":"<p>Convert flat Markdown files to Logseq's outline format.</p> <p>Usage:</p> Bash<pre><code>lqdpy -g /path/to/graph outline [OPTIONS] INPUT_FILE\n</code></pre> <p>Arguments:</p> <ul> <li><code>INPUT_FILE</code>: Path to the Markdown file to convert</li> </ul> <p>Description:</p> <p>This command reads a flat Markdown file and converts it to Logseq's indented outline structure. It processes headings and content to create a hierarchical outline that works well with Logseq's outliner interface.</p> <p>Example:</p> Bash<pre><code>lqdpy -g ~/logseq/my-graph outline notes.md\n</code></pre>"},{"location":"reference/cli/#task","title":"<code>task</code>","text":"<p>Manage tasks in your Logseq graph.</p> <p>Usage:</p> Bash<pre><code>lqd task [subcommand]\n</code></pre> <p>Description:</p> <p>Parent command for task management operations. Use subcommands to add, list, or modify tasks in your Logseq graph.</p> <p>Subcommands:</p>"},{"location":"reference/cli/#task-add","title":"<code>task add</code>","text":"<p>Add a new task to Logseq or update an existing one.</p> <p>Usage:</p> Bash<pre><code>lqd task add [task description] [OPTIONS]\n</code></pre> <p>Description:</p> <p>Adds a new TODO task to your Logseq graph. By default, tasks are added to today's journal page. You can specify a different target using flags.</p> <p>Features:</p> <ul> <li>Key-based updates: Use <code>--key</code> to search for and update existing tasks (case-insensitive)</li> <li>Flexible targeting: Add to journal pages, regular pages, or under specific blocks</li> <li>Smart search: When using <code>--key</code>, searches within the specified page/journal or block scope</li> <li>Preserve structure: When updating tasks, preserves children, properties, and logbook entries</li> </ul> <p>Flags:</p> Text Only<pre><code>-j, --journal YYYY-MM-DD    Journal date (default: today)\n-p, --page NAME             Page name to add the task to\n-b, --block TEXT            Partial text of a block to use as parent\n-k, --key TEXT              Unique key to search for existing task\n</code></pre> <p>Examples:</p> Bash<pre><code># Add a task to today's journal\nlqd task add \"Review pull request\"\n\n# Add a task to a specific page\nlqd task add \"Call client\" --page \"Work\"\n\n# Add a task to a specific journal date\nlqd task add \"Buy groceries\" --journal 2024-12-25\n\n# Update an existing task by key (preserves children and properties)\nlqd task add \"Water plants in living room\" --key \"water plants\"\n\n# Add a task under a specific block\nlqd task add \"Meeting notes\" --block \"Project A\"\n\n# Update a task within a specific block scope\nlqd task add \"Updated task name\" --block \"Project A\" --key \"task\"\n</code></pre>"},{"location":"reference/cli/#tasks","title":"<code>tasks</code>","text":"<p>List all tasks in your Logseq graph.</p> <p>Usage:</p> Bash<pre><code>lqdpy -g /path/to/graph tasks [OPTIONS]\n</code></pre> <p>Description:</p> <p>This command scans your Logseq graph and lists all tasks found in your pages. It helps you get an overview of your TODO items across all your notes.</p> <p>Example:</p> Bash<pre><code>lqdpy -g ~/logseq/my-graph tasks\n</code></pre>"},{"location":"reference/cli/#tidy-up","title":"<code>tidy-up</code>","text":"<p>Clean up and standardize your Markdown files.</p> <p>Usage:</p> Bash<pre><code>lqd tidy-up [OPTIONS] [FILES...]\n</code></pre> <p>Description:</p> <p>This command helps ensure your Markdown files follow consistent formatting rules. It performs various cleanup operations:</p> <ul> <li>Removes double spaces (except in tables)</li> <li>Removes empty bullets</li> <li>Removes unnecessary brackets from tags</li> <li>Standardizes formatting</li> </ul> <p>Example:</p> Bash<pre><code>lqd tidy-up /path/to/markdown/files/*.md\n</code></pre>"},{"location":"reference/cli/#global-flags","title":"Global Flags","text":"<p>Go CLI (<code>lqd</code>):</p> Text Only<pre><code>-h, --help\n</code></pre> <p>Show help information for any command.</p> <p>Python CLI (<code>lqdpy</code>):</p> Text Only<pre><code>-g, --graph DIRECTORY\n</code></pre> <p>Path to your Logseq graph directory. Can also be set via the <code>LOGSEQ_GRAPH_PATH</code> environment variable.</p> <p>Required: Yes (for most commands)</p>"},{"location":"reference/cli/#environment-variables","title":"Environment Variables","text":""},{"location":"reference/cli/#logseq_graph_path","title":"<code>LOGSEQ_GRAPH_PATH</code>","text":"<p>Path to your Logseq graph directory. Used by the Python CLI (<code>lqdpy</code>) as the default value for the <code>-g</code> flag, and by the <code>backlog</code> command to locate your graph.</p> <p>Example:</p> Bash<pre><code>export LOGSEQ_GRAPH_PATH=~/logseq/my-graph\nlqdpy tasks  # No need to specify -g flag\n</code></pre>"},{"location":"reference/cli/#logseq_host_url","title":"<code>LOGSEQ_HOST_URL</code>","text":"<p>Logseq API host URL. Used by the <code>backlog</code> command to connect to the Logseq API.</p> <p>Default: <code>http://localhost:12315</code></p> <p>Example:</p> Bash<pre><code>export LOGSEQ_HOST_URL=http://localhost:12315\nlqd backlog\n</code></pre>"},{"location":"reference/cli/#logseq_api_token","title":"<code>LOGSEQ_API_TOKEN</code>","text":"<p>Logseq API authentication token. Required by the <code>backlog</code> command to authenticate with the Logseq API.</p> <p>Example:</p> Bash<pre><code>export LOGSEQ_API_TOKEN=your-api-token-here\nlqd backlog\n</code></pre>"},{"location":"reference/cli/#exit-code","title":"Exit Code","text":"<p>Both CLIs use standard exit codes:</p> <ul> <li><code>0</code>: Success</li> <li><code>1</code>: General error</li> <li><code>2</code>: Command-line usage error</li> </ul>"},{"location":"reference/cli/#tips","title":"Tips","text":"<p>Combining Commands</p> <p>You can combine multiple commands using shell pipes and scripting:</p> Text Only<pre><code>```bash\n# Example: Tidy up all Markdown files in a directory\nfind ~/notes -name \"*.md\" -exec lqd tidy-up {} \\;\n```\n</code></pre> <p>Automation</p> <p>Use the Go CLI (<code>lqd</code>) in scripts and automation workflows for better performance:</p> Text Only<pre><code>```bash\n#!/bin/bash\n# Daily note automation\necho \"- $(date): Daily standup notes\" | lqd content\n```\n</code></pre> <p>Shell Aliases</p> <p>Create shell aliases for frequently used commands:</p> Text Only<pre><code>```bash\n# Add to ~/.bashrc or ~/.zshrc\nalias lqd-tasks='lqdpy -g ~/logseq/my-graph tasks'\nalias lqd-tidy='lqd tidy-up'\n```\n</code></pre>"},{"location":"reference/go/","title":"Go API","text":""},{"location":"reference/go/#go-api-reference","title":"Go API Reference","text":"<p>This section contains the API documentation for the Go implementation of Logseq Doctor.</p> <p>View on pkg.go.dev</p> <p>Documentation</p> <p>The documentation below is automatically generated from the Go source code using gomarkdoc and includes detailed API reference for all packages, including internal packages.</p>"},{"location":"reference/go/#packages","title":"Packages","text":"<p>Browse the documentation for each package:</p>"},{"location":"reference/go/#command-line-interface","title":"Command-line Interface","text":"<ul> <li>cmd - CLI implementation using Cobra</li> </ul>"},{"location":"reference/go/#public-packages","title":"Public Packages","text":"<ul> <li>pkg/set - Generic set data structure</li> </ul>"},{"location":"reference/go/#internal-packages","title":"Internal Packages","text":"<ul> <li>internal - Internal implementation details</li> <li>internal/backlog - Backlog management</li> <li>internal/testutils - Testing utilities</li> </ul>"},{"location":"reference/go/#installation","title":"Installation","text":"Bash<pre><code>go get github.com/andreoliwa/logseq-doctor\n</code></pre> <p>Or install the binary:</p> Bash<pre><code># Using Homebrew\nbrew install andreoliwa/formulae/logseq-doctor\n\n# Or download from releases\ngh release download -R andreoliwa/logseq-doctor\n</code></pre>"},{"location":"reference/go/#usage","title":"Usage","text":"Go<pre><code>import (\n    \"github.com/andreoliwa/logseq-doctor/pkg/set\"\n)\n\n// Use the set package\ns := set.NewSet[string]()\ns.Add(\"item\")\n</code></pre> <p>Or use the CLI:</p> Bash<pre><code>lqd --help\n</code></pre>"},{"location":"reference/python/","title":"Python API","text":""},{"location":"reference/python/#python-api-reference","title":"Python API Reference","text":"<p>This section contains the auto-generated API documentation for the Python implementation of Logseq Doctor.</p> <p>The Python package provides:</p> <ul> <li>API Client (<code>logseq_doctor.api</code>): Logseq API client for interacting with your graph</li> <li>CLI (<code>logseq_doctor.cli</code>): Command-line interface implementation</li> <li>Constants (<code>logseq_doctor.constants</code>): Shared constants and configuration</li> </ul>"},{"location":"reference/python/#quick-links","title":"Quick Links","text":"<ul> <li>logseq_doctor.api - API client for Logseq</li> <li>logseq_doctor.cli - CLI implementation</li> <li>logseq_doctor.constants - Constants and configuration</li> </ul>"},{"location":"reference/python/#installation","title":"Installation","text":"Bash<pre><code>pip install logseq-doctor\n</code></pre> <p>Or with <code>uv</code>:</p> Bash<pre><code>uv add logseq-doctor\n</code></pre>"},{"location":"reference/python/#usage","title":"Usage","text":"Python<pre><code>from logseq_doctor.api import Block, LogseqClient\n\n# Use the API client\nclient = LogseqClient(path=\"/path/to/graph\")\n</code></pre> <p>Or use the CLI:</p> Bash<pre><code>lqdpy --help\n</code></pre>"},{"location":"reference/go/cmd/","title":"Index","text":""},{"location":"reference/go/cmd/#cmd","title":"cmd","text":"Go<pre><code>import \"github.com/andreoliwa/lqd/cmd\"\n</code></pre>"},{"location":"reference/go/cmd/#index","title":"Index","text":"<ul> <li>Variables</li> <li>func Execute()</li> <li>func NewMdCmd(deps *MdDependencies) *cobra.Command</li> <li>func NewTaskAddCmd(deps *TaskAddDependencies) *cobra.Command</li> <li>func NewTaskCmd() *cobra.Command</li> <li>func ParseDateFromJournalFlag(journalFlag string, timeNow func() time.Time) (time.Time, error)</li> <li>func addBlockFlag(cmd *cobra.Command, flagVar *string, what string)</li> <li>func addJournalFlag(cmd *cobra.Command, flagVar *string)</li> <li>func addPageFlag(cmd *cobra.Command, flagVar *string, what string)</li> <li>func init()</li> <li>type MdDependencies</li> <li>type TaskAddDependencies</li> </ul>"},{"location":"reference/go/cmd/#variables","title":"Variables","text":"Go<pre><code>var backlogCmd = &amp;cobra.Command{\n    Use:   \"backlog [partial page names]\",\n    Short: \"Aggregate tasks from multiple pages into a backlog\",\n    Long: `The backlog command aggregates tasks from one or more pages into a unified backlog.\n\nIf partial page names are provided, only page titles that contain the provided names are processed.\n\nEach line on the \"backlog\" page that includes references to other pages or tags generates a separate backlog.\nThe first page in the line determines the name of the backlog page.\nTasks are retrieved from all provided pages or tags.\nThis setup enables users to rearrange tasks using the arrow keys and manage task states (start/stop)\ndirectly within the interface.`,\n    Run: func(_ *cobra.Command, args []string) {\n        path := os.Getenv(\"LOGSEQ_GRAPH_PATH\")\n        api := internal.NewLogseqAPI(path,\n            os.Getenv(\"LOGSEQ_HOST_URL\"), os.Getenv(\"LOGSEQ_API_TOKEN\"))\n        graph := internal.OpenGraphFromPath(path)\n        reader := backlog.NewPageConfigReader(graph, \"backlog\")\n        proc := backlog.NewBacklog(graph, api, reader, time.Now)\n\n        err := proc.ProcessAll(args)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n    },\n}\n</code></pre> <p>contentCmd represents the content command.</p> Go<pre><code>var contentCmd = &amp;cobra.Command{\n    Use:   \"content\",\n    Short: \"Append raw Markdown content to Logseq\",\n    Long: `Append raw Markdown content to Logseq.\n\nPipe your content via stdin.\nFor now, it will be appended at the end of the current journal page.`,\n    Run: func(_ *cobra.Command, _ []string) {\n        graph := internal.OpenGraphFromPath(os.Getenv(\"LOGSEQ_GRAPH_PATH\"))\n        stdin := internal.ReadFromStdin()\n\n        var targetDate time.Time\n        if journalFlag != \"\" {\n            parsedDate, err := time.Parse(\"2006-01-02\", journalFlag)\n            if err != nil {\n                log.Fatalln(\"Invalid journal date format. Use YYYY-MM-DD:\", err)\n            }\n            targetDate = parsedDate\n        } else {\n            targetDate = time.Now()\n        }\n\n        _, err := internal.AppendRawMarkdownToJournal(graph, targetDate, stdin)\n        if err != nil {\n            log.Fatalln(err)\n        }\n    },\n}\n</code></pre> <p></p> Go<pre><code>var journalFlag string //nolint:gochecknoglobals\n</code></pre> <p>mdCmd represents the md command using the default dependencies.</p> Go<pre><code>var mdCmd = NewMdCmd(nil) //nolint:gochecknoglobals\n</code></pre> <p>rootCmd represents the base command when called without any subcommands.</p> Go<pre><code>var rootCmd = &amp;cobra.Command{\n    Use:   \"lqd\",\n    Short: \"Logseq Doctor heals your Markdown files for Logseq\",\n    Long: `Logseq Doctor heals your Markdown files for Logseq.\n\nConvert flat Markdown to Logseq outline, clean up Markdown,\nprevent invalid content, and more stuff to come.\n\n\"lqdpy\" is the CLI tool originally written in Python; \"lqd\" is the Go version.\nThe intention is to slowly convert everything to Go.`,\n}\n</code></pre> <p>taskCmd represents the task command using the default dependencies.</p> Go<pre><code>var taskCmd = NewTaskCmd() //nolint:gochecknoglobals\n</code></pre> <p>tidyUpCmd represents the tidyUp command.</p> Go<pre><code>var tidyUpCmd = &amp;cobra.Command{\n    Use:   \"tidy-up file1.md [file2.md ...]\",\n    Short: \"Tidy up your Markdown files.\",\n\n    Long: `Tidy up your Markdown files, checking for invalid content and fixing some of them automatically.\n\n- Check for forbidden references to pages/tags\n- Check for running tasks (DOING)\n- Check for double spaces`,\n    Args: cobra.MinimumNArgs(1),\n    Run: func(_ *cobra.Command, args []string) {\n        graph := internal.OpenGraphFromPath(os.Getenv(\"LOGSEQ_GRAPH_PATH\"))\n\n        exitCode := 0\n        for _, path := range args {\n            if internal.TidyUpOneFile(graph, path) != 0 {\n                exitCode = 1\n            }\n        }\n        os.Exit(exitCode)\n    },\n}\n</code></pre> <p></p>"},{"location":"reference/go/cmd/#func-execute","title":"func Execute","text":"Go<pre><code>func Execute()\n</code></pre> <p>Execute adds all child commands to the root command and sets flags appropriately. This is called by main.main(). It only needs to happen once to the rootCmd.</p> <p></p>"},{"location":"reference/go/cmd/#func-newmdcmd","title":"func NewMdCmd","text":"Go<pre><code>func NewMdCmd(deps *MdDependencies) *cobra.Command\n</code></pre> <p>NewMdCmd creates a new md command with the specified dependencies. If deps is nil, it uses default implementations.</p> <p></p>"},{"location":"reference/go/cmd/#func-newtaskaddcmd","title":"func NewTaskAddCmd","text":"Go<pre><code>func NewTaskAddCmd(deps *TaskAddDependencies) *cobra.Command\n</code></pre> <p>NewTaskAddCmd creates a new task add subcommand with the specified dependencies. If deps is nil, it uses default implementations.</p> <p></p>"},{"location":"reference/go/cmd/#func-newtaskcmd","title":"func NewTaskCmd","text":"Go<pre><code>func NewTaskCmd() *cobra.Command\n</code></pre> <p>NewTaskCmd creates the parent task command.</p> <p></p>"},{"location":"reference/go/cmd/#func-parsedatefromjournalflag","title":"func ParseDateFromJournalFlag","text":"Go<pre><code>func ParseDateFromJournalFlag(journalFlag string, timeNow func() time.Time) (time.Time, error)\n</code></pre> <p>ParseDateFromJournalFlag parses the journal flag and returns the target date. If journalFlag is empty, it returns the current time from timeNow. If journalFlag is not empty, it parses it as YYYY-MM-DD format. Returns an error if the date format is invalid.</p> <p></p>"},{"location":"reference/go/cmd/#func-addblockflag","title":"func addBlockFlag","text":"Go<pre><code>func addBlockFlag(cmd *cobra.Command, flagVar *string, what string)\n</code></pre> <p>addBlockFlag adds a --block/-b flag to the command with customizable help text.</p> <p></p>"},{"location":"reference/go/cmd/#func-addjournalflag","title":"func addJournalFlag","text":"Go<pre><code>func addJournalFlag(cmd *cobra.Command, flagVar *string)\n</code></pre> <p>addJournalFlag adds a --journal/-j flag to the command.</p> <p></p>"},{"location":"reference/go/cmd/#func-addpageflag","title":"func addPageFlag","text":"Go<pre><code>func addPageFlag(cmd *cobra.Command, flagVar *string, what string)\n</code></pre> <p>addPageFlag adds a --page/-p flag to the command with customizable help text.</p> <p></p>"},{"location":"reference/go/cmd/#func-init","title":"func init","text":"Go<pre><code>func init()\n</code></pre>"},{"location":"reference/go/cmd/#type-mddependencies","title":"type MdDependencies","text":"<p>MdDependencies holds all the dependencies for the md command.</p> Go<pre><code>type MdDependencies struct {\n    InsertFn  func(*internal.InsertMarkdownOptions) error\n    OpenGraph func(string) *logseq.Graph\n    ReadStdin func() string\n    TimeNow   func() time.Time\n}\n</code></pre> <p></p>"},{"location":"reference/go/cmd/#type-taskadddependencies","title":"type TaskAddDependencies","text":"<p>TaskAddDependencies holds all the dependencies for the task add command.</p> Go<pre><code>type TaskAddDependencies struct {\n    AddTaskFn func(*internal.AddTaskOptions) error\n    OpenGraph func(string) *logseq.Graph\n    TimeNow   func() time.Time\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"reference/go/internal/","title":"Index","text":""},{"location":"reference/go/internal/#internal","title":"internal","text":"Go<pre><code>import \"github.com/andreoliwa/lqd/internal\"\n</code></pre>"},{"location":"reference/go/internal/#index","title":"Index","text":"<ul> <li>Variables</li> <li>func AddTask(opts *AddTaskOptions) error</li> <li>func AppendRawMarkdownToJournal(graph *logseq.Graph, date time.Time, rawMarkdown string) (int, error)</li> <li>func DateYYYYMMDD(time time.Time) int</li> <li>func FindBlockContainingText(page logseq.Page, searchText string) *content.Block</li> <li>func FindTaskByKey(page logseq.Page, parentBlock *content.Block, key string) *content.Block</li> <li>func InsertMarkdownToJournal(opts *InsertMarkdownOptions) error</li> <li>func IsAncestor(block, ancestor *content.Block) bool</li> <li>func IsValidMarkdownFile(filePath string) bool</li> <li>func OpenGraphFromPath(path string) *logseq.Graph</li> <li>func OpenPage(graph *logseq.Graph, pageTitle string) logseq.Page</li> <li>func ReadFromStdin() string</li> <li>func SortAndRemoveDuplicates(elements []string) []string</li> <li>func TidyUpOneFile(graph *logseq.Graph, path string) int</li> <li>func addContent(page logseq.Page, parentBlock *content.Block, contentText string) error</li> <li>func containsTextCaseInsensitive(node content.Node, searchTextLower string) bool</li> <li>func newParagraphTodoTask(name string) *content.Paragraph</li> <li>func replaceCurrentPage(query, pageTitle string) string</li> <li>func updateTaskNamePreservingChildren(task *content.Block, newName string)</li> <li>type AddTaskOptions</li> <li>type CategorizedTasks</li> <li>func NewCategorizedTasks() CategorizedTasks</li> <li>type ChangedContents</li> <li>func RemoveUnnecessaryBracketsFromTags(oldContents string) ChangedContents</li> <li>type ChangedPage</li> <li>func CheckForbiddenReferences(page logseq.Page) ChangedPage</li> <li>func CheckRunningTasks(page logseq.Page) ChangedPage</li> <li>func RemoveDoubleSpaces(page logseq.Page) ChangedPage</li> <li>func RemoveEmptyBullets(page logseq.Page) ChangedPage</li> <li>type InsertMarkdownOptions</li> <li>type LogseqAPI</li> <li>func NewLogseqAPI(path, hostURL, apiToken string) LogseqAPI</li> <li>type LogseqFinder</li> <li>func NewLogseqFinder(graph *logseq.Graph) LogseqFinder</li> <li>type TaskJSON</li> <li>func ExtractTasksFromJSON(jsonStr string) ([]TaskJSON, error)</li> <li>func (t TaskJSON) Doing() bool</li> <li>func (t TaskJSON) FutureScheduled(currentTime func() time.Time) bool</li> <li>func (t TaskJSON) Overdue(currentTime func() time.Time) bool</li> <li>type logseqAPIImpl</li> <li>func (l *logseqAPIImpl) PostQuery(query string) (string, error)</li> <li>type logseqFinderImpl</li> <li>func (f logseqFinderImpl) FindFirstQuery(pageTitle string) string</li> <li>type pageJSON</li> </ul>"},{"location":"reference/go/internal/#variables","title":"Variables","text":"Go<pre><code>var ErrFailedOpenGraph = errors.New(\"failed to open graph\")\n</code></pre> Go<pre><code>var ErrInvalidResponseStatus = errors.New(\"invalid response status\")\n</code></pre> Go<pre><code>var ErrMissingConfig = errors.New(\"LOGSEQ_API_TOKEN and LOGSEQ_HOST_URL must be set\")\n</code></pre> <p>ErrPageIsNil is returned when a page is nil.</p> Go<pre><code>var ErrPageIsNil = errors.New(\"page is nil\")\n</code></pre> <p>PageColor is a color function for page names.</p> Go<pre><code>var PageColor = color.New(color.FgHiWhite).SprintfFunc() //nolint:gochecknoglobals\n</code></pre> <p></p>"},{"location":"reference/go/internal/#func-addtask","title":"func AddTask","text":"Go<pre><code>func AddTask(opts *AddTaskOptions) error\n</code></pre> <p>AddTask adds a task to Logseq. If Key is provided, it searches for an existing task containing that key (case-insensitive) and updates it. Otherwise, creates a new task. If Page is provided, adds to that page. Otherwise, adds to journal for Date. If BlockText is provided, adds as a child of the first block containing that text.</p> <p></p>"},{"location":"reference/go/internal/#func-appendrawmarkdowntojournal","title":"func AppendRawMarkdownToJournal","text":"Go<pre><code>func AppendRawMarkdownToJournal(graph *logseq.Graph, date time.Time, rawMarkdown string) (int, error)\n</code></pre> <p>AppendRawMarkdownToJournal appends raw Markdown content to the journal page for the given date. I tried appending blocks with `logseq-go` but there is and with text containing brackets. e.g. \"[something]\" is escaped like \"\\[something\\]\" and this breaks links.</p> <p></p>"},{"location":"reference/go/internal/#func-dateyyyymmdd","title":"func DateYYYYMMDD","text":"Go<pre><code>func DateYYYYMMDD(time time.Time) int\n</code></pre> <p>DateYYYYMMDD returns the current date in YYYYMMDD format.</p> <p></p>"},{"location":"reference/go/internal/#func-findblockcontainingtext","title":"func FindBlockContainingText","text":"Go<pre><code>func FindBlockContainingText(page logseq.Page, searchText string) *content.Block\n</code></pre> <p>FindBlockContainingText searches for the first block containing the specified text using FindDeep.</p> <p></p>"},{"location":"reference/go/internal/#func-findtaskbykey","title":"func FindTaskByKey","text":"Go<pre><code>func FindTaskByKey(page logseq.Page, parentBlock *content.Block, key string) *content.Block\n</code></pre> <p>FindTaskByKey searches for a task block containing the specified key (case-insensitive). If parentBlock is provided, searches only among its children. Otherwise, searches in the entire page.</p> <p></p>"},{"location":"reference/go/internal/#func-insertmarkdowntojournal","title":"func InsertMarkdownToJournal","text":"Go<pre><code>func InsertMarkdownToJournal(opts *InsertMarkdownOptions) error\n</code></pre> <p>InsertMarkdownToJournal inserts markdown content to a journal page If ParentText is provided, it searches for the first block containing that text and inserts the content as a child block. Otherwise, appends to the end.</p> <p></p>"},{"location":"reference/go/internal/#func-isancestor","title":"func IsAncestor","text":"Go<pre><code>func IsAncestor(block, ancestor *content.Block) bool\n</code></pre> <p>IsAncestor checks if ancestor is an ancestor of block by traversing up the parent chain. Returns true if ancestor is found in the parent hierarchy of block, false otherwise. Returns true if block and ancestor are the same block.</p> <p></p>"},{"location":"reference/go/internal/#func-isvalidmarkdownfile","title":"func IsValidMarkdownFile","text":"Go<pre><code>func IsValidMarkdownFile(filePath string) bool\n</code></pre> <p>IsValidMarkdownFile checks if a file is a Markdown file, by looking at its extension, not its content.</p> <p></p>"},{"location":"reference/go/internal/#func-opengraphfrompath","title":"func OpenGraphFromPath","text":"Go<pre><code>func OpenGraphFromPath(path string) *logseq.Graph\n</code></pre> <p>OpenGraphFromPath opens a Logseq graph (from the path provided when the instance was created). It doesn't return an error and aborts the program if it fails because it's an internal function. This is done on purpose to avoid error handling boilerplate code throughout the package.</p> <p></p>"},{"location":"reference/go/internal/#func-openpage","title":"func OpenPage","text":"Go<pre><code>func OpenPage(graph *logseq.Graph, pageTitle string) logseq.Page\n</code></pre> <p>OpenPage opens a page in the Logseq graph. It aborts the program in case of error because it's an internal function. Also, it's not common to have errors when opening a page.</p> <p></p>"},{"location":"reference/go/internal/#func-readfromstdin","title":"func ReadFromStdin","text":"Go<pre><code>func ReadFromStdin() string\n</code></pre> <p>ReadFromStdin reads from stdin and returns the content as a string. It doesn't return an error and aborts the program if it fails because it's an internal function.</p> <p></p>"},{"location":"reference/go/internal/#func-sortandremoveduplicates","title":"func SortAndRemoveDuplicates","text":"Go<pre><code>func SortAndRemoveDuplicates(elements []string) []string\n</code></pre>"},{"location":"reference/go/internal/#func-tidyuponefile","title":"func TidyUpOneFile","text":"Go<pre><code>func TidyUpOneFile(graph *logseq.Graph, path string) int\n</code></pre>"},{"location":"reference/go/internal/#func-addcontent","title":"func addContent","text":"Go<pre><code>func addContent(page logseq.Page, parentBlock *content.Block, contentText string) error\n</code></pre> <p>addContent adds content either as a child block to the specified parent or as a top-level block to the page.</p> <p></p>"},{"location":"reference/go/internal/#func-containstextcaseinsensitive","title":"func containsTextCaseInsensitive","text":"Go<pre><code>func containsTextCaseInsensitive(node content.Node, searchTextLower string) bool\n</code></pre> <p>containsTextCaseInsensitive checks if a node contains the specified text (case-insensitive). It checks Text, PageLink, and Hashtag nodes.</p> <p></p>"},{"location":"reference/go/internal/#func-newparagraphtodotask","title":"func newParagraphTodoTask","text":"Go<pre><code>func newParagraphTodoTask(name string) *content.Paragraph\n</code></pre>"},{"location":"reference/go/internal/#func-replacecurrentpage","title":"func replaceCurrentPage","text":"Go<pre><code>func replaceCurrentPage(query, pageTitle string) string\n</code></pre> <p>replaceCurrentPage replaces the current page placeholder in the query with the actual page name.</p> <p></p>"},{"location":"reference/go/internal/#func-updatetasknamepreservingchildren","title":"func updateTaskNamePreservingChildren","text":"Go<pre><code>func updateTaskNamePreservingChildren(task *content.Block, newName string)\n</code></pre>"},{"location":"reference/go/internal/#type-addtaskoptions","title":"type AddTaskOptions","text":"<p>AddTaskOptions contains options for adding a task to Logseq.</p> Go<pre><code>type AddTaskOptions struct {\n    Graph     *logseq.Graph\n    Date      time.Time\n    Page      string // Page name to add the task to (empty = journal)\n    BlockText string // Partial text to search for in parent blocks\n    Key       string // Unique key to search for existing task (case-insensitive)\n    Name      string // Short name of the task\n}\n</code></pre> <p></p>"},{"location":"reference/go/internal/#type-categorizedtasks","title":"type CategorizedTasks","text":"Go<pre><code>type CategorizedTasks struct {\n    All             *set.Set[string]\n    Overdue         *set.Set[string]\n    Doing           *set.Set[string]\n    FutureScheduled *set.Set[string]\n}\n</code></pre>"},{"location":"reference/go/internal/#func-newcategorizedtasks","title":"func NewCategorizedTasks","text":"Go<pre><code>func NewCategorizedTasks() CategorizedTasks\n</code></pre>"},{"location":"reference/go/internal/#type-changedcontents","title":"type ChangedContents","text":"<p>ChangedContents is the result of a check function that modifies file contents directly without a transaction.</p> Go<pre><code>type ChangedContents struct {\n    Msg         string\n    NewContents string\n}\n</code></pre> <p></p>"},{"location":"reference/go/internal/#func-removeunnecessarybracketsfromtags","title":"func RemoveUnnecessaryBracketsFromTags","text":"Go<pre><code>func RemoveUnnecessaryBracketsFromTags(oldContents string) ChangedContents\n</code></pre> <p>RemoveUnnecessaryBracketsFromTags removes unnecessary brackets from hashtags. logseq-go rewrites tags correctly when saving the transaction, removing unnecessary brackets. But, when reading the file, the AST doesn't provide the information if a tag has brackets or not. So I would have to rewrite the file to fix them, and I don't want to do it every time there is a tag without spaces. Also, as of 2024-12-30, logseq-go has a bug when reading properties with spaces in values, which causes them to be partially removed from the file, destroying data. I will report it soon.</p> <p></p>"},{"location":"reference/go/internal/#type-changedpage","title":"type ChangedPage","text":"<p>ChangedPage is the result of a check function that modifies Markdown through a Page and a transaction.</p> Go<pre><code>type ChangedPage struct {\n    Msg     string\n    Changed bool\n}\n</code></pre> <p></p>"},{"location":"reference/go/internal/#func-checkforbiddenreferences","title":"func CheckForbiddenReferences","text":"Go<pre><code>func CheckForbiddenReferences(page logseq.Page) ChangedPage\n</code></pre> <p>CheckForbiddenReferences checks if a page has forbidden references to other pages or tags.</p> <p></p>"},{"location":"reference/go/internal/#func-checkrunningtasks","title":"func CheckRunningTasks","text":"Go<pre><code>func CheckRunningTasks(page logseq.Page) ChangedPage\n</code></pre> <p>CheckRunningTasks checks if a page has running tasks (DOING, etc.).</p> <p></p>"},{"location":"reference/go/internal/#func-removedoublespaces","title":"func RemoveDoubleSpaces","text":"Go<pre><code>func RemoveDoubleSpaces(page logseq.Page) ChangedPage\n</code></pre> <p>RemoveDoubleSpaces removes double spaces from text, page links, and tags, except for tables.</p> <p></p>"},{"location":"reference/go/internal/#func-removeemptybullets","title":"func RemoveEmptyBullets","text":"Go<pre><code>func RemoveEmptyBullets(page logseq.Page) ChangedPage\n</code></pre>"},{"location":"reference/go/internal/#type-insertmarkdownoptions","title":"type InsertMarkdownOptions","text":"<p>InsertMarkdownOptions contains options for inserting markdown content.</p> Go<pre><code>type InsertMarkdownOptions struct {\n    Graph      *logseq.Graph\n    Date       time.Time\n    Content    string\n    ParentText string // Partial text to search for in parent blocks\n}\n</code></pre> <p></p>"},{"location":"reference/go/internal/#type-logseqapi","title":"type LogseqAPI","text":"Go<pre><code>type LogseqAPI interface {\n    PostQuery(query string) (string, error)\n}\n</code></pre>"},{"location":"reference/go/internal/#func-newlogseqapi","title":"func NewLogseqAPI","text":"Go<pre><code>func NewLogseqAPI(path, hostURL, apiToken string) LogseqAPI\n</code></pre> <p>NewLogseqAPI creates a new LogseqAPI instance.</p> <p></p>"},{"location":"reference/go/internal/#type-logseqfinder","title":"type LogseqFinder","text":"Go<pre><code>type LogseqFinder interface {\n    FindFirstQuery(pageTitle string) string\n}\n</code></pre>"},{"location":"reference/go/internal/#func-newlogseqfinder","title":"func NewLogseqFinder","text":"Go<pre><code>func NewLogseqFinder(graph *logseq.Graph) LogseqFinder\n</code></pre>"},{"location":"reference/go/internal/#type-taskjson","title":"type TaskJSON","text":"Go<pre><code>type TaskJSON struct {\n    UUID      string   `json:\"uuid\"`\n    Marker    string   `json:\"marker\"`\n    Content   string   `json:\"content\"`\n    Page      pageJSON `json:\"page\"`\n    Deadline  int      `json:\"deadline\"`\n    Scheduled int      `json:\"scheduled\"`\n}\n</code></pre>"},{"location":"reference/go/internal/#func-extracttasksfromjson","title":"func ExtractTasksFromJSON","text":"Go<pre><code>func ExtractTasksFromJSON(jsonStr string) ([]TaskJSON, error)\n</code></pre>"},{"location":"reference/go/internal/#func-taskjson-doing","title":"func (TaskJSON) Doing","text":"Go<pre><code>func (t TaskJSON) Doing() bool\n</code></pre> <p>Doing checks if the task has the DOING marker.</p> <p></p>"},{"location":"reference/go/internal/#func-taskjson-futurescheduled","title":"func (TaskJSON) FutureScheduled","text":"Go<pre><code>func (t TaskJSON) FutureScheduled(currentTime func() time.Time) bool\n</code></pre> <p>FutureScheduled checks if the task is scheduled for the future (tomorrow onwards) and it's not overdue.</p> <p></p>"},{"location":"reference/go/internal/#func-taskjson-overdue","title":"func (TaskJSON) Overdue","text":"Go<pre><code>func (t TaskJSON) Overdue(currentTime func() time.Time) bool\n</code></pre> <p>Overdue checks if the task is overdue based on deadline or scheduled date.</p> <p></p>"},{"location":"reference/go/internal/#type-logseqapiimpl","title":"type logseqAPIImpl","text":"Go<pre><code>type logseqAPIImpl struct {\n    path     string\n    hostURL  string\n    apiToken string\n}\n</code></pre>"},{"location":"reference/go/internal/#func-logseqapiimpl-postquery","title":"func (*logseqAPIImpl) PostQuery","text":"Go<pre><code>func (l *logseqAPIImpl) PostQuery(query string) (string, error)\n</code></pre> <p>PostQuery sends a query to the Logseq API and returns the result as JSON.</p> <p></p>"},{"location":"reference/go/internal/#type-logseqfinderimpl","title":"type logseqFinderImpl","text":"Go<pre><code>type logseqFinderImpl struct {\n    graph *logseq.Graph\n}\n</code></pre>"},{"location":"reference/go/internal/#func-logseqfinderimpl-findfirstquery","title":"func (logseqFinderImpl) FindFirstQuery","text":"Go<pre><code>func (f logseqFinderImpl) FindFirstQuery(pageTitle string) string\n</code></pre>"},{"location":"reference/go/internal/#type-pagejson","title":"type pageJSON","text":"Go<pre><code>type pageJSON struct {\n    JournalDay int `json:\"journalDay\"`\n}\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"reference/go/internal/backlog/","title":"Index","text":""},{"location":"reference/go/internal/backlog/#backlog","title":"backlog","text":"Go<pre><code>import \"github.com/andreoliwa/lqd/internal/backlog\"\n</code></pre>"},{"location":"reference/go/internal/backlog/#index","title":"Index","text":"<ul> <li>func AddSibling(page logseq.Page, newBlock, before *content.Block, after ...*content.Block)</li> <li>func FormatCount(count int, singular, plural string) string</li> <li>func addTasksToCategories(jsonTasks []internal.TaskJSON, tasks *internal.CategorizedTasks, currentTime func() time.Time)</li> <li>func blockRefsFromPages(page logseq.Page) *set.Set[string]</li> <li>func defaultQuery(pageTitle string) string</li> <li>func nextChildHasPin(node content.Node) bool</li> <li>func printQuickCaptureURL(graph *logseq.Graph)</li> <li>func queryTasksFromPages(graph *logseq.Graph, api internal.LogseqAPI, pageTitles []string, currentTime func() time.Time) (*internal.CategorizedTasks, error)</li> <li>func queryTasksFromPagesConcurrent(api internal.LogseqAPI, pageTitles []string, tasks *internal.CategorizedTasks, finder internal.LogseqFinder, currentTime func() time.Time) (*internal.CategorizedTasks, error)</li> <li>func queryTasksFromPagesSequential(api internal.LogseqAPI, pageTitles []string, tasks *internal.CategorizedTasks, finder internal.LogseqFinder, currentTime func() time.Time) (*internal.CategorizedTasks, error)</li> <li>func queryTasksFromSinglePage(api internal.LogseqAPI, pageTitle string, finder internal.LogseqFinder) ([]internal.TaskJSON, error)</li> <li>func removeEmptyDividers(save bool, dividers ...*content.Block) bool</li> <li>type Backlog</li> <li>func NewBacklog(graph *logseq.Graph, api internal.LogseqAPI, reader ConfigReader, currentTime func() time.Time) Backlog</li> <li>type Config</li> <li>type ConfigReader</li> <li>func NewPageConfigReader(graph *logseq.Graph, configPage string) ConfigReader</li> <li>type Result</li> <li>func insertAndRemoveRefs(graph *logseq.Graph, pageTitle string, newBlockRefs, obsoleteBlockRefs, overdueBlockRefs, futureScheduledBlockRefs *set.Set[string]) (*Result, error)</li> <li>type SingleBacklogConfig</li> <li>type backlogImpl</li> <li>func (b *backlogImpl) Graph() *logseq.Graph</li> <li>func (b *backlogImpl) ProcessAll(partialNames []string) error</li> <li>func (b *backlogImpl) ProcessOne(pageTitle string, funcQueryRefs func() (*internal.CategorizedTasks, error)) (*Result, error)</li> <li>type pageConfigReader</li> <li>func (p *pageConfigReader) ReadConfig() (*Config, error)</li> </ul>"},{"location":"reference/go/internal/backlog/#func-addsibling","title":"func AddSibling","text":"Go<pre><code>func AddSibling(page logseq.Page, newBlock, before *content.Block, after ...*content.Block)\n</code></pre>"},{"location":"reference/go/internal/backlog/#func-formatcount","title":"func FormatCount","text":"Go<pre><code>func FormatCount(count int, singular, plural string) string\n</code></pre> <p>FormatCount returns a string with the count and the singular or plural form of a word.</p> <p></p>"},{"location":"reference/go/internal/backlog/#func-addtaskstocategories","title":"func addTasksToCategories","text":"Go<pre><code>func addTasksToCategories(jsonTasks []internal.TaskJSON, tasks *internal.CategorizedTasks, currentTime func() time.Time)\n</code></pre> <p>addTasksToCategories adds tasks to the appropriate categories in CategorizedTasks.</p> <p></p>"},{"location":"reference/go/internal/backlog/#func-blockrefsfrompages","title":"func blockRefsFromPages","text":"Go<pre><code>func blockRefsFromPages(page logseq.Page) *set.Set[string]\n</code></pre>"},{"location":"reference/go/internal/backlog/#func-defaultquery","title":"func defaultQuery","text":"Go<pre><code>func defaultQuery(pageTitle string) string\n</code></pre>"},{"location":"reference/go/internal/backlog/#func-nextchildhaspin","title":"func nextChildHasPin","text":"Go<pre><code>func nextChildHasPin(node content.Node) bool\n</code></pre>"},{"location":"reference/go/internal/backlog/#func-printquickcaptureurl","title":"func printQuickCaptureURL","text":"Go<pre><code>func printQuickCaptureURL(graph *logseq.Graph)\n</code></pre>"},{"location":"reference/go/internal/backlog/#func-querytasksfrompages","title":"func queryTasksFromPages","text":"Go<pre><code>func queryTasksFromPages(graph *logseq.Graph, api internal.LogseqAPI, pageTitles []string, currentTime func() time.Time) (*internal.CategorizedTasks, error)\n</code></pre> <p>queryTasksFromPages queries Logseq API for tasks from specified pages. It uses concurrent processing for multiple pages and sequential processing for a single page.</p> <p></p>"},{"location":"reference/go/internal/backlog/#func-querytasksfrompagesconcurrent","title":"func queryTasksFromPagesConcurrent","text":"Go<pre><code>func queryTasksFromPagesConcurrent(api internal.LogseqAPI, pageTitles []string, tasks *internal.CategorizedTasks, finder internal.LogseqFinder, currentTime func() time.Time) (*internal.CategorizedTasks, error)\n</code></pre> <p>queryTasksFromPagesConcurrent processes pages concurrently using goroutines.</p> <p></p>"},{"location":"reference/go/internal/backlog/#func-querytasksfrompagessequential","title":"func queryTasksFromPagesSequential","text":"Go<pre><code>func queryTasksFromPagesSequential(api internal.LogseqAPI, pageTitles []string, tasks *internal.CategorizedTasks, finder internal.LogseqFinder, currentTime func() time.Time) (*internal.CategorizedTasks, error)\n</code></pre> <p>queryTasksFromPagesSequential processes pages sequentially (original implementation).</p> <p></p>"},{"location":"reference/go/internal/backlog/#func-querytasksfromsinglepage","title":"func queryTasksFromSinglePage","text":"Go<pre><code>func queryTasksFromSinglePage(api internal.LogseqAPI, pageTitle string, finder internal.LogseqFinder) ([]internal.TaskJSON, error)\n</code></pre> <p>queryTasksFromSinglePage queries tasks from a single page and returns the JSON tasks.</p> <p></p>"},{"location":"reference/go/internal/backlog/#func-removeemptydividers","title":"func removeEmptyDividers","text":"Go<pre><code>func removeEmptyDividers(save bool, dividers ...*content.Block) bool\n</code></pre> <p>removeEmptyDividers removes empty dividers (no blocks under it) and returns true if any were removed.</p> <p></p>"},{"location":"reference/go/internal/backlog/#type-backlog","title":"type Backlog","text":"Go<pre><code>type Backlog interface {\n    Graph() *logseq.Graph\n    ProcessAll(partialNames []string) error\n    ProcessOne(pageTitle string, funcQueryRefs func() (*internal.CategorizedTasks, error)) (*Result, error)\n}\n</code></pre>"},{"location":"reference/go/internal/backlog/#func-newbacklog","title":"func NewBacklog","text":"Go<pre><code>func NewBacklog(graph *logseq.Graph, api internal.LogseqAPI, reader ConfigReader, currentTime func() time.Time) Backlog\n</code></pre>"},{"location":"reference/go/internal/backlog/#type-config","title":"type Config","text":"Go<pre><code>type Config struct {\n    FocusPage string\n    Backlogs  []SingleBacklogConfig\n}\n</code></pre>"},{"location":"reference/go/internal/backlog/#type-configreader","title":"type ConfigReader","text":"Go<pre><code>type ConfigReader interface {\n    ReadConfig() (*Config, error)\n}\n</code></pre>"},{"location":"reference/go/internal/backlog/#func-newpageconfigreader","title":"func NewPageConfigReader","text":"Go<pre><code>func NewPageConfigReader(graph *logseq.Graph, configPage string) ConfigReader\n</code></pre> <p>NewPageConfigReader creates a new ConfigReader that reads the backlog configuration from a Logseq page.</p> <p></p>"},{"location":"reference/go/internal/backlog/#type-result","title":"type Result","text":"Go<pre><code>type Result struct {\n    FocusRefsFromPage *set.Set[string]\n    ShowQuickCapture  bool\n}\n</code></pre>"},{"location":"reference/go/internal/backlog/#func-insertandremoverefs","title":"func insertAndRemoveRefs","text":"Go<pre><code>func insertAndRemoveRefs(graph *logseq.Graph, pageTitle string, newBlockRefs, obsoleteBlockRefs, overdueBlockRefs, futureScheduledBlockRefs *set.Set[string]) (*Result, error)\n</code></pre>"},{"location":"reference/go/internal/backlog/#type-singlebacklogconfig","title":"type SingleBacklogConfig","text":"Go<pre><code>type SingleBacklogConfig struct {\n    BacklogPage string\n    Icon        string\n    InputPages  []string\n}\n</code></pre>"},{"location":"reference/go/internal/backlog/#type-backlogimpl","title":"type backlogImpl","text":"Go<pre><code>type backlogImpl struct {\n    graph        *logseq.Graph\n    api          internal.LogseqAPI\n    configReader ConfigReader\n    currentTime  func() time.Time\n}\n</code></pre>"},{"location":"reference/go/internal/backlog/#func-backlogimpl-graph","title":"func (*backlogImpl) Graph","text":"Go<pre><code>func (b *backlogImpl) Graph() *logseq.Graph\n</code></pre>"},{"location":"reference/go/internal/backlog/#func-backlogimpl-processall","title":"func (*backlogImpl) ProcessAll","text":"Go<pre><code>func (b *backlogImpl) ProcessAll(partialNames []string) error\n</code></pre>"},{"location":"reference/go/internal/backlog/#func-backlogimpl-processone","title":"func (*backlogImpl) ProcessOne","text":"Go<pre><code>func (b *backlogImpl) ProcessOne(pageTitle string, funcQueryRefs func() (*internal.CategorizedTasks, error)) (*Result, error)\n</code></pre>"},{"location":"reference/go/internal/backlog/#type-pageconfigreader","title":"type pageConfigReader","text":"Go<pre><code>type pageConfigReader struct {\n    graph      *logseq.Graph\n    configPage string\n}\n</code></pre>"},{"location":"reference/go/internal/backlog/#func-pageconfigreader-readconfig","title":"func (*pageConfigReader) ReadConfig","text":"Go<pre><code>func (p *pageConfigReader) ReadConfig() (*Config, error)\n</code></pre> <p>ReadConfig reads the backlog configuration from a Logseq page.</p> <p>Generated by gomarkdoc</p>"},{"location":"reference/go/internal/testutils/","title":"Index","text":""},{"location":"reference/go/internal/testutils/#testutils","title":"testutils","text":"Go<pre><code>import \"github.com/andreoliwa/lqd/internal/testutils\"\n</code></pre>"},{"location":"reference/go/internal/testutils/#index","title":"Index","text":"<ul> <li>Variables</li> <li>func AssertGoldenJournals(t *testing.T, graph *logseq.Graph, caseDirName string, pages []string)</li> <li>func AssertGoldenPages(t *testing.T, graph *logseq.Graph, caseDirName string, pages []string)</li> <li>func AssertPagesDontExist(t *testing.T, graph *logseq.Graph, pages []string)</li> <li>func CaptureOutput(function func()) string</li> <li>func RelativeTime() time.Time</li> <li>func StubBacklog(t *testing.T, configPage, caseDirName string, apiResponses *StubAPIResponses) backlog.Backlog</li> <li>func StubGraph(t *testing.T, caseDirName string) *logseq.Graph</li> <li>func assertGoldenContent(t *testing.T, graph *logseq.Graph, journals bool, caseDirName string, pages []string)</li> <li>func stubJSONResponse(t *testing.T, basename string) (string, error)</li> <li>type QueryArg</li> <li>type StubAPIResponses</li> <li>type mockLogseqAPI</li> <li>func newMockLogseqAPI(t *testing.T, responses StubAPIResponses) *mockLogseqAPI</li> <li>func (m *mockLogseqAPI) PostQuery(query string) (string, error)</li> </ul>"},{"location":"reference/go/internal/testutils/#variables","title":"Variables","text":"Go<pre><code>var baselineTime = time.Date(2025, 4, 13, 3, 33, 0, 0, time.UTC) //nolint:gochecknoglobals\n</code></pre> Go<pre><code>var testStartTime = time.Now() //nolint:gochecknoglobals\n</code></pre>"},{"location":"reference/go/internal/testutils/#func-assertgoldenjournals","title":"func AssertGoldenJournals","text":"Go<pre><code>func AssertGoldenJournals(t *testing.T, graph *logseq.Graph, caseDirName string, pages []string)\n</code></pre>"},{"location":"reference/go/internal/testutils/#func-assertgoldenpages","title":"func AssertGoldenPages","text":"Go<pre><code>func AssertGoldenPages(t *testing.T, graph *logseq.Graph, caseDirName string, pages []string)\n</code></pre>"},{"location":"reference/go/internal/testutils/#func-assertpagesdontexist","title":"func AssertPagesDontExist","text":"Go<pre><code>func AssertPagesDontExist(t *testing.T, graph *logseq.Graph, pages []string)\n</code></pre>"},{"location":"reference/go/internal/testutils/#func-captureoutput","title":"func CaptureOutput","text":"Go<pre><code>func CaptureOutput(function func()) string\n</code></pre> <p>CaptureOutput captures both stdout and stderr. It also works with the \"color\" package.</p> <p></p>"},{"location":"reference/go/internal/testutils/#func-relativetime","title":"func RelativeTime","text":"Go<pre><code>func RelativeTime() time.Time\n</code></pre>"},{"location":"reference/go/internal/testutils/#func-stubbacklog","title":"func StubBacklog","text":"Go<pre><code>func StubBacklog(t *testing.T, configPage, caseDirName string, apiResponses *StubAPIResponses) backlog.Backlog\n</code></pre>"},{"location":"reference/go/internal/testutils/#func-stubgraph","title":"func StubGraph","text":"Go<pre><code>func StubGraph(t *testing.T, caseDirName string) *logseq.Graph\n</code></pre> <p>StubGraph opens the example graph under \"testdata\" for testing.</p> <p></p>"},{"location":"reference/go/internal/testutils/#func-assertgoldencontent","title":"func assertGoldenContent","text":"Go<pre><code>func assertGoldenContent(t *testing.T, graph *logseq.Graph, journals bool, caseDirName string, pages []string)\n</code></pre>"},{"location":"reference/go/internal/testutils/#func-stubjsonresponse","title":"func stubJSONResponse","text":"Go<pre><code>func stubJSONResponse(t *testing.T, basename string) (string, error)\n</code></pre>"},{"location":"reference/go/internal/testutils/#type-queryarg","title":"type QueryArg","text":"Go<pre><code>type QueryArg struct {\n    Contains string\n}\n</code></pre>"},{"location":"reference/go/internal/testutils/#type-stubapiresponses","title":"type StubAPIResponses","text":"Go<pre><code>type StubAPIResponses struct {\n    Queries []QueryArg\n}\n</code></pre>"},{"location":"reference/go/internal/testutils/#type-mocklogseqapi","title":"type mockLogseqAPI","text":"Go<pre><code>type mockLogseqAPI struct {\n    mock.Mock\n\n    t         *testing.T\n    responses *StubAPIResponses\n}\n</code></pre>"},{"location":"reference/go/internal/testutils/#func-newmocklogseqapi","title":"func newMockLogseqAPI","text":"Go<pre><code>func newMockLogseqAPI(t *testing.T, responses StubAPIResponses) *mockLogseqAPI\n</code></pre>"},{"location":"reference/go/internal/testutils/#func-mocklogseqapi-postquery","title":"func (*mockLogseqAPI) PostQuery","text":"Go<pre><code>func (m *mockLogseqAPI) PostQuery(query string) (string, error)\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"reference/go/pkg/set/","title":"Index","text":""},{"location":"reference/go/pkg/set/#set","title":"set","text":"Go<pre><code>import \"github.com/andreoliwa/lqd/pkg/set\"\n</code></pre>"},{"location":"reference/go/pkg/set/#index","title":"Index","text":"<ul> <li>type Set</li> <li>func NewSet[T cmp.Ordered]() *Set[T]</li> <li>func (s *Set[T]) Add(value T)</li> <li>func (s *Set[T]) Clear()</li> <li>func (s *Set[T]) Contains(value T) bool</li> <li>func (s *Set[T]) Diff(sets ...*Set[T]) *Set[T]</li> <li>func (s *Set[T]) Remove(value T)</li> <li>func (s *Set[T]) Size() int</li> <li>func (s *Set[T]) Update(sets ...*Set[T])</li> <li>func (s *Set[T]) Values() []T</li> <li>func (s *Set[T]) ValuesSorted() []T</li> </ul>"},{"location":"reference/go/pkg/set/#type-set","title":"type Set","text":"<p>Set is a simple implementation of a set using a map.</p> Go<pre><code>type Set[T cmp.Ordered] struct {\n    data map[T]struct{}\n}\n</code></pre> <p></p>"},{"location":"reference/go/pkg/set/#func-newset","title":"func NewSet","text":"Go<pre><code>func NewSet[T cmp.Ordered]() *Set[T]\n</code></pre> <p>NewSet creates and returns a new set.</p> <p></p>"},{"location":"reference/go/pkg/set/#func-sett-add","title":"func (*Set[T]) Add","text":"Go<pre><code>func (s *Set[T]) Add(value T)\n</code></pre> <p>Add inserts an element into the set.</p> <p></p>"},{"location":"reference/go/pkg/set/#func-sett-clear","title":"func (*Set[T]) Clear","text":"Go<pre><code>func (s *Set[T]) Clear()\n</code></pre> <p>Clear removes all elements from the set.</p> <p></p>"},{"location":"reference/go/pkg/set/#func-sett-contains","title":"func (*Set[T]) Contains","text":"Go<pre><code>func (s *Set[T]) Contains(value T) bool\n</code></pre> <p>Contains checks if an element exists in the set.</p> <p></p>"},{"location":"reference/go/pkg/set/#func-sett-diff","title":"func (*Set[T]) Diff","text":"Go<pre><code>func (s *Set[T]) Diff(sets ...*Set[T]) *Set[T]\n</code></pre> <p>Diff returns a new set containing elements that are in the current set but not in the provided sets.</p> <p></p>"},{"location":"reference/go/pkg/set/#func-sett-remove","title":"func (*Set[T]) Remove","text":"Go<pre><code>func (s *Set[T]) Remove(value T)\n</code></pre> <p>Remove deletes an element from the set.</p> <p></p>"},{"location":"reference/go/pkg/set/#func-sett-size","title":"func (*Set[T]) Size","text":"Go<pre><code>func (s *Set[T]) Size() int\n</code></pre> <p>Size returns the number of elements in the set.</p> <p></p>"},{"location":"reference/go/pkg/set/#func-sett-update","title":"func (*Set[T]) Update","text":"Go<pre><code>func (s *Set[T]) Update(sets ...*Set[T])\n</code></pre> <p>Update adds all elements from the given sets into the current set.</p> <p></p>"},{"location":"reference/go/pkg/set/#func-sett-values","title":"func (*Set[T]) Values","text":"Go<pre><code>func (s *Set[T]) Values() []T\n</code></pre> <p>Values returns all elements in the set as a slice.</p> <p></p>"},{"location":"reference/go/pkg/set/#func-sett-valuessorted","title":"func (*Set[T]) ValuesSorted","text":"Go<pre><code>func (s *Set[T]) ValuesSorted() []T\n</code></pre> <p>ValuesSorted returns all elements in the set as a sorted slice.</p> <p>Generated by gomarkdoc</p>"},{"location":"reference/python/SUMMARY/","title":"SUMMARY","text":"<ul> <li>logseq_doctor<ul> <li>__init__</li> <li>__main__</li> <li>api</li> <li>cli</li> <li>constants</li> </ul> </li> </ul>"},{"location":"reference/python/__init__/","title":"logseq_doctor","text":""},{"location":"reference/python/__init__/#logseq_doctor_1","title":"logseq_doctor","text":""},{"location":"reference/python/__init__/#logseq_doctor","title":"<code>logseq_doctor</code>","text":"<p>Logseq Doctor: heal your Markdown files.</p>"},{"location":"reference/python/__init__/#logseq_doctor.LogseqRenderer","title":"<code>LogseqRenderer</code>","text":"<p>               Bases: <code>BaseRenderer</code></p> <p>Render Markdown as an outline with bullets, like Logseq expects.</p> Source code in <code>src/logseq_doctor/__init__.py</code> Python<pre><code>class LogseqRenderer(BaseRenderer):\n    \"\"\"Render Markdown as an outline with bullets, like Logseq expects.\"\"\"\n\n    def __init__(self, *extras: token.Token) -&gt; None:\n        super().__init__(*extras)\n        self.current_level = 0\n        self.bullet = \"-\"\n\n    def outline(self, indent: int, text: str, *, nl: bool = True) -&gt; str:\n        \"\"\"Render a line of text with the correct indentation.\"\"\"\n        leading_spaces = \"  \" * indent\n        new_line_at_the_end = os.linesep if nl else \"\"\n        return f\"{leading_spaces}{self.bullet} {text}{new_line_at_the_end}\"\n\n    def render_heading(self, token: block_token.Heading | block_token.SetextHeading) -&gt; str:\n        \"\"\"Setext headings: https://spec.commonmark.org/0.30/#setext-headings.\"\"\"\n        if isinstance(token, block_token.SetextHeading):\n            # For now, only dealing with level 2 setext headers (dashes)\n            return self.render_inner(token) + f\"{os.linesep}{CHAR_DASH * 3}{os.linesep}\"\n\n        self.current_level = token.level\n        hashes = \"#\" * token.level\n        inner = self.render_inner(token)\n        return self.outline(token.level - 1, f\"{hashes} {inner}\")\n\n    def render_line_break(self, token: span_token.LineBreak) -&gt; str:\n        \"\"\"Render a line break.\"\"\"\n        return token.content + os.linesep\n\n    def render_paragraph(self, token: block_token.Paragraph) -&gt; str:\n        \"\"\"Render a paragraph with the correct indentation.\"\"\"\n        input_lines = self.render_inner(token).strip().splitlines()\n        output_lines: list[str] = [self.outline(self.current_level, line, nl=False) for line in input_lines]\n        return os.linesep.join(output_lines) + os.linesep\n\n    def render_link(self, token: span_token.Link) -&gt; str:\n        \"\"\"Render a link as a Markdown link.\"\"\"\n        text = self.render_inner(token)\n        url = token.target\n        return f\"[{text}]({url})\"\n\n    def render_list_item(self, token: block_token.ListItem) -&gt; str:\n        \"\"\"Render a list item with the correct indentation.\"\"\"\n        if len(token.children) &lt;= 1:\n            return self.render_inner(token)\n\n        self.current_level += 1\n\n        inner = self.render_inner(token)\n        headless_parent_with_children = inner.lstrip(f\"{self.bullet} \")\n        value_before_changing_level = self.outline(self.current_level - 1, headless_parent_with_children, nl=False)\n\n        self.current_level -= 1\n        return value_before_changing_level\n\n    def render_thematic_break(self, token: block_token.ThematicBreak) -&gt; str:  # noqa: ARG002\n        \"\"\"Render a horizontal rule as a line of dashes.\"\"\"\n        return f\"{CHAR_DASH * 3}{os.linesep}\"\n</code></pre>"},{"location":"reference/python/__init__/#logseq_doctor.LogseqRenderer.outline","title":"<code>outline(indent, text, *, nl=True)</code>","text":"<p>Render a line of text with the correct indentation.</p> Source code in <code>src/logseq_doctor/__init__.py</code> Python<pre><code>def outline(self, indent: int, text: str, *, nl: bool = True) -&gt; str:\n    \"\"\"Render a line of text with the correct indentation.\"\"\"\n    leading_spaces = \"  \" * indent\n    new_line_at_the_end = os.linesep if nl else \"\"\n    return f\"{leading_spaces}{self.bullet} {text}{new_line_at_the_end}\"\n</code></pre>"},{"location":"reference/python/__init__/#logseq_doctor.LogseqRenderer.render_heading","title":"<code>render_heading(token)</code>","text":"<p>Setext headings: https://spec.commonmark.org/0.30/#setext-headings.</p> Source code in <code>src/logseq_doctor/__init__.py</code> Python<pre><code>def render_heading(self, token: block_token.Heading | block_token.SetextHeading) -&gt; str:\n    \"\"\"Setext headings: https://spec.commonmark.org/0.30/#setext-headings.\"\"\"\n    if isinstance(token, block_token.SetextHeading):\n        # For now, only dealing with level 2 setext headers (dashes)\n        return self.render_inner(token) + f\"{os.linesep}{CHAR_DASH * 3}{os.linesep}\"\n\n    self.current_level = token.level\n    hashes = \"#\" * token.level\n    inner = self.render_inner(token)\n    return self.outline(token.level - 1, f\"{hashes} {inner}\")\n</code></pre>"},{"location":"reference/python/__init__/#logseq_doctor.LogseqRenderer.render_line_break","title":"<code>render_line_break(token)</code>","text":"<p>Render a line break.</p> Source code in <code>src/logseq_doctor/__init__.py</code> Python<pre><code>def render_line_break(self, token: span_token.LineBreak) -&gt; str:\n    \"\"\"Render a line break.\"\"\"\n    return token.content + os.linesep\n</code></pre>"},{"location":"reference/python/__init__/#logseq_doctor.LogseqRenderer.render_paragraph","title":"<code>render_paragraph(token)</code>","text":"<p>Render a paragraph with the correct indentation.</p> Source code in <code>src/logseq_doctor/__init__.py</code> Python<pre><code>def render_paragraph(self, token: block_token.Paragraph) -&gt; str:\n    \"\"\"Render a paragraph with the correct indentation.\"\"\"\n    input_lines = self.render_inner(token).strip().splitlines()\n    output_lines: list[str] = [self.outline(self.current_level, line, nl=False) for line in input_lines]\n    return os.linesep.join(output_lines) + os.linesep\n</code></pre>"},{"location":"reference/python/__init__/#logseq_doctor.LogseqRenderer.render_link","title":"<code>render_link(token)</code>","text":"<p>Render a link as a Markdown link.</p> Source code in <code>src/logseq_doctor/__init__.py</code> Python<pre><code>def render_link(self, token: span_token.Link) -&gt; str:\n    \"\"\"Render a link as a Markdown link.\"\"\"\n    text = self.render_inner(token)\n    url = token.target\n    return f\"[{text}]({url})\"\n</code></pre>"},{"location":"reference/python/__init__/#logseq_doctor.LogseqRenderer.render_list_item","title":"<code>render_list_item(token)</code>","text":"<p>Render a list item with the correct indentation.</p> Source code in <code>src/logseq_doctor/__init__.py</code> Python<pre><code>def render_list_item(self, token: block_token.ListItem) -&gt; str:\n    \"\"\"Render a list item with the correct indentation.\"\"\"\n    if len(token.children) &lt;= 1:\n        return self.render_inner(token)\n\n    self.current_level += 1\n\n    inner = self.render_inner(token)\n    headless_parent_with_children = inner.lstrip(f\"{self.bullet} \")\n    value_before_changing_level = self.outline(self.current_level - 1, headless_parent_with_children, nl=False)\n\n    self.current_level -= 1\n    return value_before_changing_level\n</code></pre>"},{"location":"reference/python/__init__/#logseq_doctor.LogseqRenderer.render_thematic_break","title":"<code>render_thematic_break(token)</code>","text":"<p>Render a horizontal rule as a line of dashes.</p> Source code in <code>src/logseq_doctor/__init__.py</code> Python<pre><code>def render_thematic_break(self, token: block_token.ThematicBreak) -&gt; str:  # noqa: ARG002\n    \"\"\"Render a horizontal rule as a line of dashes.\"\"\"\n    return f\"{CHAR_DASH * 3}{os.linesep}\"\n</code></pre>"},{"location":"reference/python/__init__/#logseq_doctor.flat_markdown_to_outline","title":"<code>flat_markdown_to_outline(markdown_contents)</code>","text":"<p>Convert flat Markdown to an outline.</p> Source code in <code>src/logseq_doctor/__init__.py</code> Python<pre><code>def flat_markdown_to_outline(markdown_contents: str) -&gt; str:\n    \"\"\"Convert flat Markdown to an outline.\"\"\"\n    return mistletoe.markdown(markdown_contents, LogseqRenderer)\n</code></pre>"},{"location":"reference/python/__main__/","title":"logseq_doctor.main","text":""},{"location":"reference/python/__main__/#logseq_doctormain","title":"logseq_doctor.main","text":""},{"location":"reference/python/__main__/#logseq_doctor.__main__","title":"<code>__main__</code>","text":"<p>Entrypoint module, in case you use <code>python -mlogseq_doctor</code>.</p> <p>Why does this file exist, and why main? For more info, read:</p> <ul> <li>https://www.python.org/dev/peps/pep-0338/</li> <li>https://docs.python.org/2/using/cmdline.html#cmdoption-m</li> <li>https://docs.python.org/3/using/cmdline.html#cmdoption-m</li> </ul>"},{"location":"reference/python/api/","title":"logseq_doctor.api","text":""},{"location":"reference/python/api/#logseq_doctorapi","title":"logseq_doctor.api","text":""},{"location":"reference/python/api/#logseq_doctor.api","title":"<code>api</code>","text":"<p>Logseq API client.</p>"},{"location":"reference/python/api/#logseq_doctor.api.Block","title":"<code>Block</code>  <code>dataclass</code>","text":"<p>Logseq block.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>@dataclass(frozen=True)\nclass Block:\n    \"\"\"Logseq block.\"\"\"\n\n    block_id: UUID\n    journal_iso_date: int\n    page_title: str\n    raw_content: str\n    marker: str\n\n    @property\n    def pretty_content(self) -&gt; str:\n        \"\"\"Return the block content without the marker.\"\"\"\n        if self.raw_content.startswith(self.marker):\n            len_marker = len(self.marker)\n            return self.raw_content[len_marker:].strip()\n        return self.raw_content\n\n    @property\n    def embed(self) -&gt; str:\n        \"\"\"Return the block content as an embed.\"\"\"\n        return f\"{{{{embed (({self.block_id}))}}}}\"\n\n    def url(self, graph_name: str) -&gt; str:\n        \"\"\"Build a Logseq block URL.\"\"\"\n        return f\"logseq://graph/{graph_name}?block-id={self.block_id}\"\n\n    @staticmethod\n    def indent(text: str, *, level: int = 0, nl: bool = False) -&gt; str:\n        \"\"\"Indent text by the desired level, preserving tabs.\"\"\"\n        spaces = CHAR_SPACE * (level * 2)\n        return indent(dedent(text.replace(CHAR_TAB, CHAR_NBSP)).strip().replace(CHAR_NBSP, CHAR_TAB), spaces) + (\n            os.linesep if nl else \"\"\n        )\n\n    @staticmethod\n    def sort_by_date(blocks: list) -&gt; list:\n        \"\"\"Sort a list of blocks by date.\"\"\"\n        return sorted(blocks, key=lambda row: (row.journal_iso_date, row.raw_content))\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Block.pretty_content","title":"<code>pretty_content</code>  <code>property</code>","text":"<p>Return the block content without the marker.</p>"},{"location":"reference/python/api/#logseq_doctor.api.Block.embed","title":"<code>embed</code>  <code>property</code>","text":"<p>Return the block content as an embed.</p>"},{"location":"reference/python/api/#logseq_doctor.api.Block.url","title":"<code>url(graph_name)</code>","text":"<p>Build a Logseq block URL.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>def url(self, graph_name: str) -&gt; str:\n    \"\"\"Build a Logseq block URL.\"\"\"\n    return f\"logseq://graph/{graph_name}?block-id={self.block_id}\"\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Block.indent","title":"<code>indent(text, *, level=0, nl=False)</code>  <code>staticmethod</code>","text":"<p>Indent text by the desired level, preserving tabs.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>@staticmethod\ndef indent(text: str, *, level: int = 0, nl: bool = False) -&gt; str:\n    \"\"\"Indent text by the desired level, preserving tabs.\"\"\"\n    spaces = CHAR_SPACE * (level * 2)\n    return indent(dedent(text.replace(CHAR_TAB, CHAR_NBSP)).strip().replace(CHAR_NBSP, CHAR_TAB), spaces) + (\n        os.linesep if nl else \"\"\n    )\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Block.sort_by_date","title":"<code>sort_by_date(blocks)</code>  <code>staticmethod</code>","text":"<p>Sort a list of blocks by date.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>@staticmethod\ndef sort_by_date(blocks: list) -&gt; list:\n    \"\"\"Sort a list of blocks by date.\"\"\"\n    return sorted(blocks, key=lambda row: (row.journal_iso_date, row.raw_content))\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Logseq","title":"<code>Logseq</code>  <code>dataclass</code>","text":"<p>Logseq API client.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>@dataclass(frozen=True)\nclass Logseq:\n    \"\"\"Logseq API client.\"\"\"\n\n    url: str\n    token: str\n    graph_path: Path\n\n    @property\n    def graph_name(self) -&gt; str:\n        \"\"\"Return the graph name from the path.\"\"\"\n        return self.graph_path.stem\n\n    def _run_query(self, query: str) -&gt; dict:\n        session = requests.Session()\n        session.headers.update(\n            {\n                \"Authorization\": f\"Bearer {self.token}\",\n                \"Content-Type\": \"application/json\",\n            },\n        )\n        resp = session.post(f\"{self.url}/api\", json={\"method\": \"logseq.db.q\", \"args\": [query]})\n        resp.raise_for_status()\n        return resp.json()\n\n    def query_blocks(self, query: str) -&gt; list[Block]:\n        \"\"\"Query Logseq API and return blocks.\"\"\"\n        rows: list[Block] = []\n        for obj in self._run_query(query):\n            page = obj.get(\"page\", {})\n            block_id = obj.get(\"uuid\")\n            rows.append(\n                Block(\n                    block_id=UUID(block_id),\n                    journal_iso_date=page.get(\"journalDay\", 0),\n                    page_title=page.get(\"originalName\"),\n                    raw_content=obj.get(\"content\").splitlines()[0],\n                    marker=obj.get(\"marker\"),\n                ),\n            )\n        return rows\n\n    def query_json(self, query: str) -&gt; str:\n        \"\"\"Query Logseq API and return JSON.\"\"\"\n        return json.dumps(self._run_query(query))\n\n    def page_from_name(self, name: str) -&gt; Page:\n        \"\"\"Return a Page object from a page name.\"\"\"\n        return Page(self.graph_path.expanduser() / \"pages\" / f\"{name}.md\")\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Logseq.graph_name","title":"<code>graph_name</code>  <code>property</code>","text":"<p>Return the graph name from the path.</p>"},{"location":"reference/python/api/#logseq_doctor.api.Logseq.query_blocks","title":"<code>query_blocks(query)</code>","text":"<p>Query Logseq API and return blocks.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>def query_blocks(self, query: str) -&gt; list[Block]:\n    \"\"\"Query Logseq API and return blocks.\"\"\"\n    rows: list[Block] = []\n    for obj in self._run_query(query):\n        page = obj.get(\"page\", {})\n        block_id = obj.get(\"uuid\")\n        rows.append(\n            Block(\n                block_id=UUID(block_id),\n                journal_iso_date=page.get(\"journalDay\", 0),\n                page_title=page.get(\"originalName\"),\n                raw_content=obj.get(\"content\").splitlines()[0],\n                marker=obj.get(\"marker\"),\n            ),\n        )\n    return rows\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Logseq.query_json","title":"<code>query_json(query)</code>","text":"<p>Query Logseq API and return JSON.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>def query_json(self, query: str) -&gt; str:\n    \"\"\"Query Logseq API and return JSON.\"\"\"\n    return json.dumps(self._run_query(query))\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Logseq.page_from_name","title":"<code>page_from_name(name)</code>","text":"<p>Return a Page object from a page name.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>def page_from_name(self, name: str) -&gt; Page:\n    \"\"\"Return a Page object from a page name.\"\"\"\n    return Page(self.graph_path.expanduser() / \"pages\" / f\"{name}.md\")\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Slice","title":"<code>Slice</code>  <code>dataclass</code>","text":"<p>Slice of Markdown blocks in a Logseq page.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>@dataclass(frozen=True)\nclass Slice:\n    \"\"\"Slice of Markdown blocks in a Logseq page.\"\"\"\n\n    content: str\n    start_index: int\n    end_index: int\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Page","title":"<code>Page</code>  <code>dataclass</code>","text":"<p>Logseq page.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>@dataclass(frozen=True)\nclass Page:\n    \"\"\"Logseq page.\"\"\"\n\n    path: Path\n\n    def url(self, graph_name: str) -&gt; str:\n        \"\"\"Build a Logseq page URL.\"\"\"\n        page = urllib.parse.quote(self.path.stem)\n        return f\"logseq://graph/{graph_name}?page={page}\"\n\n    def _open(self, mode: str = \"\") -&gt; TextIO:\n        return self.path.open(mode or (\"r+\" if self.path.exists() else \"w\"))\n\n    def add_line_break(self) -&gt; bool:\n        \"\"\"Return True if a line break was added to the end of the file.\"\"\"\n        if not self.path.exists():\n            return False\n        len_line_break = len(os.linesep)\n        with self._open(\"rb+\") as file:\n            file.seek(-1 * len_line_break, 2)\n            last_chars = file.read(len_line_break)\n            if last_chars != os.linesep.encode():\n                file.write(os.linesep.encode())\n                return True\n        return False\n\n    def remove_line_break(self) -&gt; bool:\n        \"\"\"Return True if a line break was removed from the end of the file.\"\"\"\n        if not self.path.exists():\n            return False\n        content = self.path.read_text()\n        len_line_break = len(os.linesep)\n        self.path.write_text(content[: -1 * len_line_break])\n        return True\n\n    def append(self, text: str, *, level: int = 0) -&gt; None:\n        \"\"\"Append text to the end of page.\"\"\"\n        with self._open() as file:\n            file.seek(0, SEEK_END)\n            file.write(Block.indent(text, level=level) + os.linesep)\n\n    def insert(self, text: str, start: int, *, level: int = 0) -&gt; int:\n        \"\"\"Insert text at the desired offset. Return the next insert position.\"\"\"\n        with self._open() as file:\n            file.seek(start)\n            remaining_content = file.read()\n\n            # A dirty hack to adjust the start position of a file:\n            # search for the nearest new line and move the pointer if found.\n            # For some reasons, in one file the start was off by 2;\n            # maybe it's the BOM in the beginning of the file?\n            # TODO: this whole logic of manipulating blocks should be done with Markdown AST...\n            pos_nearest_new_line = remaining_content[:BEGINNING].find(os.linesep)\n            if pos_nearest_new_line != -1:\n                start += pos_nearest_new_line + 1\n                remaining_content = remaining_content[pos_nearest_new_line + 1 :]\n\n            file.seek(start)\n            new_text = Block.indent(text, level=level) + os.linesep\n            file.write(new_text)\n            pos_after_writing = file.tell()\n            file.write(remaining_content)\n            return pos_after_writing\n\n    def replace(self, new_text: str, start: int, end: int, *, level: int = 0) -&gt; None:\n        \"\"\"Replace text at the desired offset.\"\"\"\n        with self._open() as file:\n            file.seek(end)\n            remaining_content = file.read()\n\n            file.seek(start)\n            file.write(Block.indent(new_text, level=level) + os.linesep)\n            file.write(remaining_content)\n\n    def find_slice(\n        self,\n        search_string: str,\n        *,\n        start: int = 0,\n        end: int | None = None,\n        level: int | None = None,\n    ) -&gt; Slice | None:\n        \"\"\"Find a slice of Markdown blocks in a Logseq page.\"\"\"\n        try:\n            # TODO: The right way would be to navigate the Markdown AST.\n            #  This is a hacky/buggy solution that works for now, for most cases.\n            content = self.path.read_text()\n            relative_content = content[start:] if end is None else content[start:end]\n            pos_search_string = relative_content.find(search_string)\n            if pos_search_string == -1:\n                return None\n\n            previous_line_break = self._find_previous_line_break(relative_content, pos_search_string, level)\n            slice_start = previous_line_break + 1\n\n            column = relative_content[slice_start:].find(CHAR_DASH)\n            if column == -1:\n                column = 0  # TODO: test this case\n\n            spaces = os.linesep + (CHAR_SPACE * column)\n            spaces_with_dash = spaces + CHAR_DASH\n\n            pos_last_line = relative_content[slice_start:].find(spaces_with_dash)\n            if pos_last_line == -1:\n                pos_last_line = 0\n                while True:\n                    pos_next = relative_content[slice_start + pos_last_line :].find(spaces)\n                    if pos_next == -1:\n                        break\n                    pos_last_line += pos_next + 1\n\n            pos_next_line_break = relative_content[slice_start + pos_last_line :].find(os.linesep)\n            # TODO: test: file without line break at the end\n            slice_end = (\n                len(relative_content)\n                if pos_next_line_break == -1\n                else slice_start + pos_last_line + pos_next_line_break + 1\n            )\n\n            if end is not None and slice_end &gt; end:\n                return None\n\n            return Slice(\n                content=str(content[slice_start + start : slice_end + start]),\n                start_index=slice_start + start,\n                end_index=slice_end + start,\n            )\n        except (FileNotFoundError, ValueError):\n            return None\n\n    @staticmethod\n    def _find_previous_line_break(relative_content: str, pos_search_string: int, level: int | None = None) -&gt; int:\n        if level is None:\n            bullet = CHAR_DASH + CHAR_SPACE\n            previous_dash = relative_content[:pos_search_string].rfind(bullet)\n            if previous_dash == -1:\n                msg = \"No bullet found before search string\"\n                raise ValueError(msg)\n\n            return relative_content[:previous_dash].rfind(os.linesep)\n            # There are no line breaks before on the first line of the file\n        bullet = os.linesep + (CHAR_SPACE * (level * 2)) + CHAR_DASH + CHAR_SPACE\n        return relative_content[:pos_search_string].rfind(bullet)\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Page.url","title":"<code>url(graph_name)</code>","text":"<p>Build a Logseq page URL.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>def url(self, graph_name: str) -&gt; str:\n    \"\"\"Build a Logseq page URL.\"\"\"\n    page = urllib.parse.quote(self.path.stem)\n    return f\"logseq://graph/{graph_name}?page={page}\"\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Page.add_line_break","title":"<code>add_line_break()</code>","text":"<p>Return True if a line break was added to the end of the file.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>def add_line_break(self) -&gt; bool:\n    \"\"\"Return True if a line break was added to the end of the file.\"\"\"\n    if not self.path.exists():\n        return False\n    len_line_break = len(os.linesep)\n    with self._open(\"rb+\") as file:\n        file.seek(-1 * len_line_break, 2)\n        last_chars = file.read(len_line_break)\n        if last_chars != os.linesep.encode():\n            file.write(os.linesep.encode())\n            return True\n    return False\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Page.remove_line_break","title":"<code>remove_line_break()</code>","text":"<p>Return True if a line break was removed from the end of the file.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>def remove_line_break(self) -&gt; bool:\n    \"\"\"Return True if a line break was removed from the end of the file.\"\"\"\n    if not self.path.exists():\n        return False\n    content = self.path.read_text()\n    len_line_break = len(os.linesep)\n    self.path.write_text(content[: -1 * len_line_break])\n    return True\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Page.append","title":"<code>append(text, *, level=0)</code>","text":"<p>Append text to the end of page.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>def append(self, text: str, *, level: int = 0) -&gt; None:\n    \"\"\"Append text to the end of page.\"\"\"\n    with self._open() as file:\n        file.seek(0, SEEK_END)\n        file.write(Block.indent(text, level=level) + os.linesep)\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Page.insert","title":"<code>insert(text, start, *, level=0)</code>","text":"<p>Insert text at the desired offset. Return the next insert position.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>def insert(self, text: str, start: int, *, level: int = 0) -&gt; int:\n    \"\"\"Insert text at the desired offset. Return the next insert position.\"\"\"\n    with self._open() as file:\n        file.seek(start)\n        remaining_content = file.read()\n\n        # A dirty hack to adjust the start position of a file:\n        # search for the nearest new line and move the pointer if found.\n        # For some reasons, in one file the start was off by 2;\n        # maybe it's the BOM in the beginning of the file?\n        # TODO: this whole logic of manipulating blocks should be done with Markdown AST...\n        pos_nearest_new_line = remaining_content[:BEGINNING].find(os.linesep)\n        if pos_nearest_new_line != -1:\n            start += pos_nearest_new_line + 1\n            remaining_content = remaining_content[pos_nearest_new_line + 1 :]\n\n        file.seek(start)\n        new_text = Block.indent(text, level=level) + os.linesep\n        file.write(new_text)\n        pos_after_writing = file.tell()\n        file.write(remaining_content)\n        return pos_after_writing\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Page.replace","title":"<code>replace(new_text, start, end, *, level=0)</code>","text":"<p>Replace text at the desired offset.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>def replace(self, new_text: str, start: int, end: int, *, level: int = 0) -&gt; None:\n    \"\"\"Replace text at the desired offset.\"\"\"\n    with self._open() as file:\n        file.seek(end)\n        remaining_content = file.read()\n\n        file.seek(start)\n        file.write(Block.indent(new_text, level=level) + os.linesep)\n        file.write(remaining_content)\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Page.find_slice","title":"<code>find_slice(search_string, *, start=0, end=None, level=None)</code>","text":"<p>Find a slice of Markdown blocks in a Logseq page.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>def find_slice(\n    self,\n    search_string: str,\n    *,\n    start: int = 0,\n    end: int | None = None,\n    level: int | None = None,\n) -&gt; Slice | None:\n    \"\"\"Find a slice of Markdown blocks in a Logseq page.\"\"\"\n    try:\n        # TODO: The right way would be to navigate the Markdown AST.\n        #  This is a hacky/buggy solution that works for now, for most cases.\n        content = self.path.read_text()\n        relative_content = content[start:] if end is None else content[start:end]\n        pos_search_string = relative_content.find(search_string)\n        if pos_search_string == -1:\n            return None\n\n        previous_line_break = self._find_previous_line_break(relative_content, pos_search_string, level)\n        slice_start = previous_line_break + 1\n\n        column = relative_content[slice_start:].find(CHAR_DASH)\n        if column == -1:\n            column = 0  # TODO: test this case\n\n        spaces = os.linesep + (CHAR_SPACE * column)\n        spaces_with_dash = spaces + CHAR_DASH\n\n        pos_last_line = relative_content[slice_start:].find(spaces_with_dash)\n        if pos_last_line == -1:\n            pos_last_line = 0\n            while True:\n                pos_next = relative_content[slice_start + pos_last_line :].find(spaces)\n                if pos_next == -1:\n                    break\n                pos_last_line += pos_next + 1\n\n        pos_next_line_break = relative_content[slice_start + pos_last_line :].find(os.linesep)\n        # TODO: test: file without line break at the end\n        slice_end = (\n            len(relative_content)\n            if pos_next_line_break == -1\n            else slice_start + pos_last_line + pos_next_line_break + 1\n        )\n\n        if end is not None and slice_end &gt; end:\n            return None\n\n        return Slice(\n            content=str(content[slice_start + start : slice_end + start]),\n            start_index=slice_start + start,\n            end_index=slice_end + start,\n        )\n    except (FileNotFoundError, ValueError):\n        return None\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Kanban","title":"<code>Kanban</code>  <code>dataclass</code>","text":"<p>Create/update the Kanban board used by the https://github.com/sethyuan/logseq-plugin-kanban-board plugin.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>@dataclass\nclass Kanban:\n    \"\"\"Create/update the Kanban board used by the https://github.com/sethyuan/logseq-plugin-kanban-board plugin.\"\"\"\n\n    page: Page\n    blocks: list[Block]\n\n    _renderer: Slice = field(init=False)\n\n    def find(self) -&gt; Slice:\n        \"\"\"Find a Kanban board in the page.\"\"\"\n        self._renderer = self.page.find_slice(KANBAN_BOARD_SEARCH_STRING)\n        return self._renderer\n\n    @staticmethod\n    def _generate_kanban_id() -&gt; UUID:  # pragma: no cover\n        \"\"\"Generate a random UUID for the Kanban board. Mocked on tests.\"\"\"\n        return uuid4()\n\n    @staticmethod\n    def render_header(kanban_id: UUID, title: str) -&gt; str:\n        \"\"\"Render the header of the Kanban board.\"\"\"\n        return Block.indent(\n            f\"\"\"\n            - {{{{{KANBAN_BOARD_SEARCH_STRING} {kanban_id}, {KANBAN_LIST}}}}}\n            - {title}\n              id:: {kanban_id}\n              collapsed:: true\n            \"\"\",\n        )\n\n    @staticmethod\n    def render_column(column: str) -&gt; tuple[str, str]:\n        \"\"\"Render a column for the Kanban board.\"\"\"\n        key = f\"{KANBAN_LIST}:: {column}\"\n        card = Block.indent(\n            f\"\"\"\n            {CHAR_TAB}- placeholder #.kboard-placeholder\n            {CHAR_TAB}  {key}\n            \"\"\",\n        )\n        return key, card\n\n    @classmethod\n    def render_card(cls, column: str, block: Block) -&gt; str:\n        \"\"\"Render a collapsed card for the Kanban board.\"\"\"\n        if block.journal_iso_date:\n            content = block.pretty_content\n        else:\n            content = f\"{block.page_title}: {block.pretty_content} #[[{block.page_title}]]\"\n        return Block.indent(\n            f\"\"\"\n            {CHAR_TAB}- {content}\n            {CHAR_TAB}  {KANBAN_LIST}:: {column}\n            {CHAR_TAB}  collapsed:: true\n            {CHAR_TAB}{CHAR_TAB}- {block.embed}\n            \"\"\",\n        )\n\n    def add(self) -&gt; None:\n        \"\"\"Add a Kanban board to the page.\"\"\"\n        if not self.page.path.exists():\n            msg = f\"Page {self.page.path} does not exist\"\n            raise FileNotFoundError(msg)\n\n        self.page.append(self.render_header(self._generate_kanban_id(), KANBAN_BOARD_TITLE))\n\n        columns = set()\n        for block in self.blocks:\n            column = block.marker or KANBAN_UNKNOWN_COLUMN\n            if column not in columns:\n                columns.add(column)\n                _, card = self.render_column(column)\n                self.page.append(card)\n\n            self.page.append(self.render_card(column, block))\n\n    def update(self) -&gt; None:\n        \"\"\"Update an existing Kanban board.\"\"\"\n        kanban_id = UUID(self._renderer.content.split(\",\")[1].strip())\n        board_slice = self.page.find_slice(f\"id:: {kanban_id}\", start=self._renderer.end_index)\n        board_start = board_slice.start_index\n        board_end = board_slice.end_index\n\n        # Insert the next card at the beginning of the board\n        first_child = self.page.find_slice(f\"{KANBAN_LIST}:: \", start=board_start, end=board_end)\n        if not first_child:\n            return\n        pos_next_insert = first_child.start_index\n\n        columns = set()\n        for block in self.blocks:\n            if self.page.find_slice(str(block.block_id), start=board_start, end=board_end):\n                continue\n\n            column = block.marker or KANBAN_UNKNOWN_COLUMN\n            if column not in columns:\n                columns.add(column)\n                key, card = self.render_column(column)\n                if not self.page.find_slice(key, start=board_start, end=board_end):\n                    pos = self.page.insert(card, start=pos_next_insert)\n                    pos_next_insert = max(pos_next_insert, pos)\n                    board_end += len(card) + len(os.linesep)\n\n            card = self.render_card(column, block)\n            pos = self.page.insert(card, start=pos_next_insert)\n            pos_next_insert = max(pos_next_insert, pos)\n            board_end += len(card) + len(os.linesep)\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Kanban.find","title":"<code>find()</code>","text":"<p>Find a Kanban board in the page.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>def find(self) -&gt; Slice:\n    \"\"\"Find a Kanban board in the page.\"\"\"\n    self._renderer = self.page.find_slice(KANBAN_BOARD_SEARCH_STRING)\n    return self._renderer\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Kanban.render_header","title":"<code>render_header(kanban_id, title)</code>  <code>staticmethod</code>","text":"<p>Render the header of the Kanban board.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>@staticmethod\ndef render_header(kanban_id: UUID, title: str) -&gt; str:\n    \"\"\"Render the header of the Kanban board.\"\"\"\n    return Block.indent(\n        f\"\"\"\n        - {{{{{KANBAN_BOARD_SEARCH_STRING} {kanban_id}, {KANBAN_LIST}}}}}\n        - {title}\n          id:: {kanban_id}\n          collapsed:: true\n        \"\"\",\n    )\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Kanban.render_column","title":"<code>render_column(column)</code>  <code>staticmethod</code>","text":"<p>Render a column for the Kanban board.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>@staticmethod\ndef render_column(column: str) -&gt; tuple[str, str]:\n    \"\"\"Render a column for the Kanban board.\"\"\"\n    key = f\"{KANBAN_LIST}:: {column}\"\n    card = Block.indent(\n        f\"\"\"\n        {CHAR_TAB}- placeholder #.kboard-placeholder\n        {CHAR_TAB}  {key}\n        \"\"\",\n    )\n    return key, card\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Kanban.render_card","title":"<code>render_card(column, block)</code>  <code>classmethod</code>","text":"<p>Render a collapsed card for the Kanban board.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>@classmethod\ndef render_card(cls, column: str, block: Block) -&gt; str:\n    \"\"\"Render a collapsed card for the Kanban board.\"\"\"\n    if block.journal_iso_date:\n        content = block.pretty_content\n    else:\n        content = f\"{block.page_title}: {block.pretty_content} #[[{block.page_title}]]\"\n    return Block.indent(\n        f\"\"\"\n        {CHAR_TAB}- {content}\n        {CHAR_TAB}  {KANBAN_LIST}:: {column}\n        {CHAR_TAB}  collapsed:: true\n        {CHAR_TAB}{CHAR_TAB}- {block.embed}\n        \"\"\",\n    )\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Kanban.add","title":"<code>add()</code>","text":"<p>Add a Kanban board to the page.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>def add(self) -&gt; None:\n    \"\"\"Add a Kanban board to the page.\"\"\"\n    if not self.page.path.exists():\n        msg = f\"Page {self.page.path} does not exist\"\n        raise FileNotFoundError(msg)\n\n    self.page.append(self.render_header(self._generate_kanban_id(), KANBAN_BOARD_TITLE))\n\n    columns = set()\n    for block in self.blocks:\n        column = block.marker or KANBAN_UNKNOWN_COLUMN\n        if column not in columns:\n            columns.add(column)\n            _, card = self.render_column(column)\n            self.page.append(card)\n\n        self.page.append(self.render_card(column, block))\n</code></pre>"},{"location":"reference/python/api/#logseq_doctor.api.Kanban.update","title":"<code>update()</code>","text":"<p>Update an existing Kanban board.</p> Source code in <code>src/logseq_doctor/api.py</code> Python<pre><code>def update(self) -&gt; None:\n    \"\"\"Update an existing Kanban board.\"\"\"\n    kanban_id = UUID(self._renderer.content.split(\",\")[1].strip())\n    board_slice = self.page.find_slice(f\"id:: {kanban_id}\", start=self._renderer.end_index)\n    board_start = board_slice.start_index\n    board_end = board_slice.end_index\n\n    # Insert the next card at the beginning of the board\n    first_child = self.page.find_slice(f\"{KANBAN_LIST}:: \", start=board_start, end=board_end)\n    if not first_child:\n        return\n    pos_next_insert = first_child.start_index\n\n    columns = set()\n    for block in self.blocks:\n        if self.page.find_slice(str(block.block_id), start=board_start, end=board_end):\n            continue\n\n        column = block.marker or KANBAN_UNKNOWN_COLUMN\n        if column not in columns:\n            columns.add(column)\n            key, card = self.render_column(column)\n            if not self.page.find_slice(key, start=board_start, end=board_end):\n                pos = self.page.insert(card, start=pos_next_insert)\n                pos_next_insert = max(pos_next_insert, pos)\n                board_end += len(card) + len(os.linesep)\n\n        card = self.render_card(column, block)\n        pos = self.page.insert(card, start=pos_next_insert)\n        pos_next_insert = max(pos_next_insert, pos)\n        board_end += len(card) + len(os.linesep)\n</code></pre>"},{"location":"reference/python/cli/","title":"logseq_doctor.cli","text":""},{"location":"reference/python/cli/#logseq_doctorcli","title":"logseq_doctor.cli","text":""},{"location":"reference/python/cli/#logseq_doctor.cli","title":"<code>cli</code>","text":"<p>Module that contains the command line app.</p> <p>Why does this file exist, and why not put this in main?</p> <p>You might be tempted to import things from main later, but that will cause   problems: the code will get executed twice:</p> <ul> <li>When you run <code>python -m logseq_doctor</code> python will execute     <code>__main__.py</code> as a script. That means there won't be any     <code>logseq_doctor.__main__</code> in <code>sys.modules</code>.</li> <li>When you import main it will get executed again (as a module) because     there's no <code>logseq_doctor.__main__</code> in <code>sys.modules</code>.</li> </ul> <p>Also see (1) from https://click.pocoo.org/5/setuptools/#setuptools-integration</p>"},{"location":"reference/python/cli/#logseq_doctor.cli.GlobalOptions","title":"<code>GlobalOptions</code>  <code>dataclass</code>","text":"<p>Global options for every sub-command.</p> Source code in <code>src/logseq_doctor/cli.py</code> Python<pre><code>@dataclass\nclass GlobalOptions:\n    \"\"\"Global options for every sub-command.\"\"\"\n\n    logseq_graph_path: Path\n</code></pre>"},{"location":"reference/python/cli/#logseq_doctor.cli.TaskFormat","title":"<code>TaskFormat</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Task format.</p> Source code in <code>src/logseq_doctor/cli.py</code> Python<pre><code>class TaskFormat(str, Enum):\n    \"\"\"Task format.\"\"\"\n\n    text = \"text\"\n</code></pre>"},{"location":"reference/python/cli/#logseq_doctor.cli.lqdpy","title":"<code>lqdpy(ctx, logseq_graph_path=typer.Option(..., '--graph', '-g', help='Logseq graph', envvar='LOGSEQ_GRAPH_PATH', dir_okay=True, file_okay=False))</code>","text":"<p>Logseq Doctor: heal your flat old Markdown files before importing them.</p> Source code in <code>src/logseq_doctor/cli.py</code> Python<pre><code>@app.callback()\ndef lqdpy(\n    ctx: typer.Context,\n    logseq_graph_path: Path = typer.Option(  # noqa: B008\n        ...,\n        \"--graph\",\n        \"-g\",\n        help=\"Logseq graph\",\n        envvar=\"LOGSEQ_GRAPH_PATH\",\n        dir_okay=True,\n        file_okay=False,\n    ),\n) -&gt; None:\n    \"\"\"Logseq Doctor: heal your flat old Markdown files before importing them.\"\"\"\n    ctx.obj = GlobalOptions(logseq_graph_path)\n</code></pre>"},{"location":"reference/python/cli/#logseq_doctor.cli.outline","title":"<code>outline(text_file)</code>","text":"<p>Convert flat Markdown to outline.</p> Source code in <code>src/logseq_doctor/cli.py</code> Python<pre><code>@app.command(no_args_is_help=True)\ndef outline(text_file: typer.FileText) -&gt; None:\n    \"\"\"Convert flat Markdown to outline.\"\"\"\n    typer.echo(flat_markdown_to_outline(text_file.read()))\n</code></pre>"},{"location":"reference/python/cli/#logseq_doctor.cli.tasks","title":"<code>tasks(ctx, tag_or_page=typer.Argument(None, metavar='TAG', help='Tags or pages to query'), logseq_host_url=typer.Option(..., '--host', '-h', help='Logseq host', envvar='LOGSEQ_HOST_URL'), logseq_api_token=typer.Option(..., '--token', '-t', help='Logseq API token', envvar='LOGSEQ_API_TOKEN'), json_=typer.Option(False, '--json', help='Output in JSON format'), verbose=typer.Option(False, '--verbose', '-v', help='Verbose output'), completed=typer.Option(False, '--completed', '-c', help='Include canceled and done tasks'))</code>","text":"<p>List tasks in Logseq.</p> Source code in <code>src/logseq_doctor/cli.py</code> Python<pre><code>@app.command()\ndef tasks(  # noqa: PLR0913\n    ctx: typer.Context,\n    tag_or_page: list[str] = typer.Argument(None, metavar=\"TAG\", help=\"Tags or pages to query\"),  # noqa: B008\n    logseq_host_url: str = typer.Option(..., \"--host\", \"-h\", help=\"Logseq host\", envvar=\"LOGSEQ_HOST_URL\"),\n    logseq_api_token: str = typer.Option(..., \"--token\", \"-t\", help=\"Logseq API token\", envvar=\"LOGSEQ_API_TOKEN\"),\n    json_: bool = typer.Option(False, \"--json\", help=\"Output in JSON format\"),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"Verbose output\"),\n    completed: bool = typer.Option(False, \"--completed\", \"-c\", help=\"Include canceled and done tasks\"),\n) -&gt; None:\n    \"\"\"List tasks in Logseq.\"\"\"\n    logseq = Logseq(logseq_host_url, logseq_api_token, cast(\"GlobalOptions\", ctx.obj).logseq_graph_path)\n    condition = \"\"\n    if tag_or_page:\n        if len(tag_or_page) == 1:\n            condition = f\" [[{tag_or_page[0]}]]\"\n        else:\n            pages = \" \".join([f\"[[{tp}]]\" for tp in tag_or_page])\n            condition = f\" (or {pages})\"\n\n    task_statuses = \"TODO DOING WAITING NOW LATER\"\n    if completed:\n        task_statuses += \" CANCELED DONE\"\n\n    query = f\"(and{condition} (task {task_statuses}))\"\n    if verbose:\n        typer.echo(f\"Query: {query}\")\n\n    if json_:\n        typer.echo(logseq.query_json(query))\n        return\n\n    blocks_sorted_by_date = Block.sort_by_date(logseq.query_blocks(query))\n    for block in blocks_sorted_by_date:\n        typer.secho(f\"{block.page_title}\u00a7\", fg=typer.colors.GREEN, nl=False)\n        typer.secho(block.url(logseq.graph_name), fg=typer.colors.BLUE, bold=True, nl=False)\n        typer.echo(f\"\u00a7{block.raw_content}\")\n</code></pre>"},{"location":"reference/python/constants/","title":"logseq_doctor.constants","text":""},{"location":"reference/python/constants/#logseq_doctorconstants","title":"logseq_doctor.constants","text":""},{"location":"reference/python/constants/#logseq_doctor.constants","title":"<code>constants</code>","text":"<p>Constants.</p>"}]}